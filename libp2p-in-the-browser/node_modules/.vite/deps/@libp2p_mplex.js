import {
  require_any_signal,
  require_rate_limiter_flexible
} from "./chunk-J7R3FAMY.js";
import {
  Uint8ArrayList,
  pipe
} from "./chunk-CRB7ZAE2.js";
import {
  pushable,
  pushableV
} from "./chunk-I6BFH7TY.js";
import {
  abortableSource
} from "./chunk-BUAMSZU7.js";
import {
  require_varint
} from "./chunk-RZC6SFPH.js";
import {
  __toESM,
  bases,
  logger,
  require_err_code
} from "./chunk-WITB7XN5.js";

// node_modules/@libp2p/mplex/dist/src/encode.js
var import_varint = __toESM(require_varint(), 1);

// node_modules/@libp2p/mplex/dist/src/alloc-unsafe-browser.js
function allocUnsafe(size) {
  return new Uint8Array(size);
}

// node_modules/@libp2p/mplex/dist/src/message-types.js
var MessageTypes;
(function(MessageTypes2) {
  MessageTypes2[MessageTypes2["NEW_STREAM"] = 0] = "NEW_STREAM";
  MessageTypes2[MessageTypes2["MESSAGE_RECEIVER"] = 1] = "MESSAGE_RECEIVER";
  MessageTypes2[MessageTypes2["MESSAGE_INITIATOR"] = 2] = "MESSAGE_INITIATOR";
  MessageTypes2[MessageTypes2["CLOSE_RECEIVER"] = 3] = "CLOSE_RECEIVER";
  MessageTypes2[MessageTypes2["CLOSE_INITIATOR"] = 4] = "CLOSE_INITIATOR";
  MessageTypes2[MessageTypes2["RESET_RECEIVER"] = 5] = "RESET_RECEIVER";
  MessageTypes2[MessageTypes2["RESET_INITIATOR"] = 6] = "RESET_INITIATOR";
})(MessageTypes || (MessageTypes = {}));
var MessageTypeNames = Object.freeze({
  0: "NEW_STREAM",
  1: "MESSAGE_RECEIVER",
  2: "MESSAGE_INITIATOR",
  3: "CLOSE_RECEIVER",
  4: "CLOSE_INITIATOR",
  5: "RESET_RECEIVER",
  6: "RESET_INITIATOR"
});
var InitiatorMessageTypes = Object.freeze({
  NEW_STREAM: MessageTypes.NEW_STREAM,
  MESSAGE: MessageTypes.MESSAGE_INITIATOR,
  CLOSE: MessageTypes.CLOSE_INITIATOR,
  RESET: MessageTypes.RESET_INITIATOR
});
var ReceiverMessageTypes = Object.freeze({
  MESSAGE: MessageTypes.MESSAGE_RECEIVER,
  CLOSE: MessageTypes.CLOSE_RECEIVER,
  RESET: MessageTypes.RESET_RECEIVER
});

// node_modules/@libp2p/mplex/dist/src/encode.js
var POOL_SIZE = 10 * 1024;
var Encoder = class {
  constructor() {
    this._pool = allocUnsafe(POOL_SIZE);
    this._poolOffset = 0;
  }
  write(msg) {
    const pool = this._pool;
    let offset = this._poolOffset;
    import_varint.default.encode(msg.id << 3 | msg.type, pool, offset);
    offset += import_varint.default.encode.bytes;
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      import_varint.default.encode(msg.data.length, pool, offset);
    } else {
      import_varint.default.encode(0, pool, offset);
    }
    offset += import_varint.default.encode.bytes;
    const header = pool.subarray(this._poolOffset, offset);
    if (POOL_SIZE - offset < 100) {
      this._pool = allocUnsafe(POOL_SIZE);
      this._poolOffset = 0;
    } else {
      this._poolOffset = offset;
    }
    if ((msg.type === MessageTypes.NEW_STREAM || msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) && msg.data != null) {
      return [
        header,
        ...msg.data instanceof Uint8Array ? [msg.data] : msg.data
      ];
    }
    return [
      header
    ];
  }
};
var encoder = new Encoder();
async function* encode(source) {
  for await (const msg of source) {
    if (Array.isArray(msg)) {
      for (const m of msg) {
        yield* encoder.write(m);
      }
    } else {
      yield* encoder.write(msg);
    }
  }
}

// node_modules/@libp2p/mplex/dist/src/decode.js
var Decoder = class {
  constructor() {
    this._buffer = new Uint8ArrayList();
    this._headerInfo = null;
  }
  write(chunk) {
    if (chunk == null || chunk.length === 0) {
      return [];
    }
    this._buffer.append(chunk);
    const msgs = [];
    while (this._buffer.length !== 0) {
      if (this._headerInfo == null) {
        try {
          this._headerInfo = this._decodeHeader(this._buffer);
        } catch (_) {
          break;
        }
      }
      const { id, type, length, offset } = this._headerInfo;
      const bufferedDataLength = this._buffer.length - offset;
      if (bufferedDataLength < length) {
        break;
      }
      const msg = {
        id,
        type
      };
      if (type === MessageTypes.NEW_STREAM || type === MessageTypes.MESSAGE_INITIATOR || type === MessageTypes.MESSAGE_RECEIVER) {
        msg.data = this._buffer.sublist(offset, offset + length);
      }
      msgs.push(msg);
      this._buffer.consume(offset + length);
      this._headerInfo = null;
    }
    return msgs;
  }
  _decodeHeader(data) {
    const { value: h, offset } = readVarInt(data);
    const { value: length, offset: end } = readVarInt(data, offset);
    const type = h & 7;
    if (MessageTypeNames[type] == null) {
      throw new Error(`Invalid type received: ${type}`);
    }
    return { id: h >> 3, type, offset: offset + end, length };
  }
};
var MSB = 128;
var REST = 127;
function readVarInt(buf, offset = 0) {
  let res = 0;
  let shift = 0;
  let counter = offset;
  let b;
  const l = buf.length;
  do {
    if (counter >= l || shift > 49) {
      offset = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf.get(counter++);
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);
  offset = counter - offset;
  return {
    value: res,
    offset
  };
}
async function* decode(source) {
  const decoder = new Decoder();
  for await (const chunk of source) {
    const msgs = decoder.write(chunk);
    if (msgs.length > 0) {
      yield msgs;
    }
  }
}

// node_modules/@libp2p/mplex/dist/src/restrict-size.js
var MAX_MSG_SIZE = 1 << 20;
function restrictSize(max) {
  const maxSize = max ?? MAX_MSG_SIZE;
  const checkSize = (msg) => {
    if (msg.type !== MessageTypes.NEW_STREAM && msg.type !== MessageTypes.MESSAGE_INITIATOR && msg.type !== MessageTypes.MESSAGE_RECEIVER) {
      return;
    }
    if (msg.data.byteLength > maxSize) {
      throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
    }
  };
  return (source) => {
    return async function* restrictSize2() {
      for await (const msg of source) {
        if (Array.isArray(msg)) {
          msg.forEach(checkSize);
          yield* msg;
        } else {
          checkSize(msg);
          yield msg;
        }
      }
    }();
  };
}

// node_modules/@libp2p/mplex/dist/src/stream.js
var import_err_code = __toESM(require_err_code(), 1);
var import_any_signal = __toESM(require_any_signal(), 1);

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe2(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec(name, prefix, encode2, decode2) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode: encode2
    },
    decoder: {
      decode: decode2
    }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder2 = new TextEncoder();
  return encoder2.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i = 0; i < buf.length; i++) {
    string2 += String.fromCharCode(buf[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe2(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/from-string.js
function fromString(string2, encoding = "utf8") {
  const base = bases_default[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base.decoder.decode(`${base.prefix}${string2}`);
}

// node_modules/@libp2p/mplex/dist/src/stream.js
var log = logger("libp2p:mplex:stream");
var ERR_STREAM_RESET = "ERR_STREAM_RESET";
var ERR_STREAM_ABORT = "ERR_STREAM_ABORT";
var ERR_SINK_ENDED = "ERR_SINK_ENDED";
var ERR_DOUBLE_SINK = "ERR_DOUBLE_SINK";
function createStream(options) {
  const { id, name, send, onEnd, type = "initiator", maxMsgSize = MAX_MSG_SIZE } = options;
  const abortController = new AbortController();
  const resetController = new AbortController();
  const closeController = new AbortController();
  const Types = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
  const externalId = type === "initiator" ? `i${id}` : `r${id}`;
  const streamName = `${name == null ? id : name}`;
  let sourceEnded = false;
  let sinkEnded = false;
  let sinkSunk = false;
  let endErr;
  const timeline = {
    open: Date.now()
  };
  const onSourceEnd = (err) => {
    if (sourceEnded) {
      return;
    }
    sourceEnded = true;
    log.trace("%s stream %s source end - err: %o", type, streamName, err);
    if (err != null && endErr == null) {
      endErr = err;
    }
    if (sinkEnded) {
      stream.stat.timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const onSinkEnd = (err) => {
    if (sinkEnded) {
      return;
    }
    sinkEnded = true;
    log.trace("%s stream %s sink end - err: %o", type, streamName, err);
    if (err != null && endErr == null) {
      endErr = err;
    }
    if (sourceEnded) {
      timeline.close = Date.now();
      if (onEnd != null) {
        onEnd(endErr);
      }
    }
  };
  const streamSource = pushable({
    onEnd: onSourceEnd
  });
  const stream = {
    close: () => {
      log.trace("%s stream %s close", type, streamName);
      stream.closeRead();
      stream.closeWrite();
    },
    closeRead: () => {
      log.trace("%s stream %s closeRead", type, streamName);
      if (sourceEnded) {
        return;
      }
      streamSource.end();
    },
    closeWrite: () => {
      log.trace("%s stream %s closeWrite", type, streamName);
      if (sinkEnded) {
        return;
      }
      closeController.abort();
      try {
        send({ id, type: Types.CLOSE });
      } catch (err) {
        log.trace("%s stream %s error sending close", type, name, err);
      }
      onSinkEnd();
    },
    abort: (err) => {
      log.trace("%s stream %s abort", type, streamName, err);
      streamSource.end(err);
      abortController.abort();
      onSinkEnd(err);
    },
    reset: () => {
      const err = (0, import_err_code.default)(new Error("stream reset"), ERR_STREAM_RESET);
      resetController.abort();
      streamSource.end(err);
      onSinkEnd(err);
    },
    sink: async (source) => {
      if (sinkSunk) {
        throw (0, import_err_code.default)(new Error("sink already called on stream"), ERR_DOUBLE_SINK);
      }
      sinkSunk = true;
      if (sinkEnded) {
        throw (0, import_err_code.default)(new Error("stream closed for writing"), ERR_SINK_ENDED);
      }
      source = abortableSource(source, (0, import_any_signal.anySignal)([
        abortController.signal,
        resetController.signal,
        closeController.signal
      ]));
      try {
        if (type === "initiator") {
          send({ id, type: InitiatorMessageTypes.NEW_STREAM, data: new Uint8ArrayList(fromString(streamName)) });
        }
        const uint8ArrayList = new Uint8ArrayList();
        for await (const data of source) {
          if (data.length <= maxMsgSize) {
            send({ id, type: Types.MESSAGE, data: data instanceof Uint8ArrayList ? data : new Uint8ArrayList(data) });
          } else {
            uint8ArrayList.append(data);
            while (uint8ArrayList.length !== 0) {
              if (uint8ArrayList.length <= maxMsgSize) {
                send({ id, type: Types.MESSAGE, data: uint8ArrayList.sublist() });
                uint8ArrayList.consume(uint8ArrayList.length);
                break;
              }
              send({ id, type: Types.MESSAGE, data: uint8ArrayList.sublist(0, maxMsgSize) });
              uint8ArrayList.consume(maxMsgSize);
            }
          }
        }
      } catch (err) {
        if (err.type === "aborted" && err.message === "The operation was aborted") {
          if (closeController.signal.aborted) {
            return;
          }
          if (resetController.signal.aborted) {
            err.message = "stream reset";
            err.code = ERR_STREAM_RESET;
          }
          if (abortController.signal.aborted) {
            err.message = "stream aborted";
            err.code = ERR_STREAM_ABORT;
          }
        }
        if (err.code === ERR_STREAM_RESET) {
          log.trace("%s stream %s reset", type, name);
        } else {
          log.trace("%s stream %s error", type, name, err);
          try {
            send({ id, type: Types.RESET });
          } catch (err2) {
            log.trace("%s stream %s error sending reset", type, name, err2);
          }
        }
        streamSource.end(err);
        onSinkEnd(err);
        return;
      }
      try {
        send({ id, type: Types.CLOSE });
      } catch (err) {
        log.trace("%s stream %s error sending close", type, name, err);
      }
      onSinkEnd();
    },
    source: streamSource,
    sourcePush: (data) => {
      streamSource.push(data);
    },
    sourceReadableLength() {
      return streamSource.readableLength;
    },
    stat: {
      direction: type === "initiator" ? "outbound" : "inbound",
      timeline
    },
    metadata: {},
    id: externalId
  };
  return stream;
}

// node_modules/@libp2p/mplex/node_modules/uint8arrays/dist/src/to-string.js
function toString(array, encoding = "utf8") {
  const base = bases_default[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/mplex/dist/src/mplex.js
var import_err_code2 = __toESM(require_err_code(), 1);
var import_rate_limiter_flexible = __toESM(require_rate_limiter_flexible(), 1);
var import_any_signal2 = __toESM(require_any_signal(), 1);
var log2 = logger("libp2p:mplex");
var MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION = 1024;
var MAX_STREAM_BUFFER_SIZE = 1024 * 1024 * 4;
var DISCONNECT_THRESHOLD = 5;
function printMessage(msg) {
  const output = {
    ...msg,
    type: `${MessageTypeNames[msg.type]} (${msg.type})`
  };
  if (msg.type === MessageTypes.NEW_STREAM) {
    output.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray());
  }
  if (msg.type === MessageTypes.MESSAGE_INITIATOR || msg.type === MessageTypes.MESSAGE_RECEIVER) {
    output.data = toString(msg.data instanceof Uint8Array ? msg.data : msg.data.subarray(), "base16");
  }
  return output;
}
var MplexStreamMuxer = class {
  constructor(init) {
    this.protocol = "/mplex/6.7.0";
    init = init ?? {};
    this._streamId = 0;
    this._streams = {
      initiators: /* @__PURE__ */ new Map(),
      receivers: /* @__PURE__ */ new Map()
    };
    this._init = init;
    this.sink = this._createSink();
    const source = this._createSource();
    this._source = source;
    this.source = source;
    this.closeController = new AbortController();
    this.rateLimiter = new import_rate_limiter_flexible.RateLimiterMemory({
      points: init.disconnectThreshold ?? DISCONNECT_THRESHOLD,
      duration: 1
    });
  }
  get streams() {
    const streams = [];
    for (const stream of this._streams.initiators.values()) {
      streams.push(stream);
    }
    for (const stream of this._streams.receivers.values()) {
      streams.push(stream);
    }
    return streams;
  }
  newStream(name) {
    if (this.closeController.signal.aborted) {
      throw new Error("Muxer already closed");
    }
    const id = this._streamId++;
    name = name == null ? id.toString() : name.toString();
    const registry = this._streams.initiators;
    return this._newStream({ id, name, type: "initiator", registry });
  }
  close(err) {
    if (this.closeController.signal.aborted)
      return;
    if (err != null) {
      this.streams.forEach((s) => s.abort(err));
    } else {
      this.streams.forEach((s) => s.close());
    }
    this.closeController.abort();
  }
  _newReceiverStream(options) {
    const { id, name } = options;
    const registry = this._streams.receivers;
    return this._newStream({ id, name, type: "receiver", registry });
  }
  _newStream(options) {
    const { id, name, type, registry } = options;
    log2("new %s stream %s %s", type, id);
    if (type === "initiator" && this._streams.initiators.size === (this._init.maxOutboundStreams ?? MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION)) {
      throw (0, import_err_code2.default)(new Error("Too many outbound streams open"), "ERR_TOO_MANY_OUTBOUND_STREAMS");
    }
    if (registry.has(id)) {
      throw new Error(`${type} stream ${id} already exists!`);
    }
    const send = (msg) => {
      if (log2.enabled) {
        log2.trace("%s stream %s send", type, id, printMessage(msg));
      }
      this._source.push(msg);
    };
    const onEnd = () => {
      log2("%s stream with id %s and protocol %s ended", type, id, stream.stat.protocol);
      registry.delete(id);
      if (this._init.onStreamEnd != null) {
        this._init.onStreamEnd(stream);
      }
    };
    const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._init.maxMsgSize });
    registry.set(id, stream);
    return stream;
  }
  _createSink() {
    const sink = async (source) => {
      const abortSignals = [this.closeController.signal];
      if (this._init.signal != null) {
        abortSignals.push(this._init.signal);
      }
      source = abortableSource(source, (0, import_any_signal2.default)(abortSignals));
      try {
        await pipe(source, decode, restrictSize(this._init.maxMsgSize), async (source2) => {
          for await (const msg of source2) {
            await this._handleIncoming(msg);
          }
        });
        this._source.end();
      } catch (err) {
        log2("error in sink", err);
        this._source.end(err);
      }
    };
    return sink;
  }
  _createSource() {
    const onEnd = (err) => {
      this.close(err);
    };
    const source = pushableV({
      objectMode: true,
      onEnd
    });
    return Object.assign(encode(source), {
      push: source.push,
      end: source.end,
      return: source.return
    });
  }
  async _handleIncoming(message) {
    const { id, type } = message;
    if (log2.enabled) {
      log2.trace("incoming message", printMessage(message));
    }
    if (message.type === MessageTypes.NEW_STREAM) {
      if (this._streams.receivers.size === (this._init.maxInboundStreams ?? MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)) {
        log2("too many inbound streams open");
        this._source.push({
          id,
          type: MessageTypes.RESET_RECEIVER
        });
        try {
          await this.rateLimiter.consume("new-stream", 1);
        } catch {
          log2("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection");
          this._source.end(new Error("Too many open streams"));
          return;
        }
        return;
      }
      const stream2 = this._newReceiverStream({ id, name: toString(message.data instanceof Uint8Array ? message.data : message.data.subarray()) });
      if (this._init.onIncomingStream != null) {
        this._init.onIncomingStream(stream2);
      }
      return;
    }
    const list = (type & 1) === 1 ? this._streams.initiators : this._streams.receivers;
    const stream = list.get(id);
    if (stream == null) {
      log2("missing stream %s for message type %s", id, MessageTypeNames[type]);
      return;
    }
    const maxBufferSize = this._init.maxStreamBufferSize ?? MAX_STREAM_BUFFER_SIZE;
    switch (type) {
      case MessageTypes.MESSAGE_INITIATOR:
      case MessageTypes.MESSAGE_RECEIVER:
        if (stream.sourceReadableLength() > maxBufferSize) {
          this._source.push({
            id: message.id,
            type: type === MessageTypes.MESSAGE_INITIATOR ? MessageTypes.RESET_RECEIVER : MessageTypes.RESET_INITIATOR
          });
          const error = (0, import_err_code2.default)(new Error("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers"), "ERR_STREAM_INPUT_BUFFER_FULL");
          stream.abort(error);
          return;
        }
        stream.sourcePush(message.data);
        break;
      case MessageTypes.CLOSE_INITIATOR:
      case MessageTypes.CLOSE_RECEIVER:
        stream.closeRead();
        break;
      case MessageTypes.RESET_INITIATOR:
      case MessageTypes.RESET_RECEIVER:
        stream.reset();
        break;
      default:
        log2("unknown message type %s", type);
    }
  }
};

// node_modules/@libp2p/mplex/dist/src/index.js
var Mplex = class {
  constructor(init = {}) {
    this.protocol = "/mplex/6.7.0";
    this._init = init;
  }
  createStreamMuxer(init = {}) {
    return new MplexStreamMuxer({
      ...init,
      ...this._init
    });
  }
};
function mplex(init = {}) {
  return () => new Mplex(init);
}
export {
  mplex
};
//# sourceMappingURL=@libp2p_mplex.js.map
