import {
  decode,
  encode,
  generateKeyPair,
  handshake,
  importKey,
  marshalPrivateKey,
  marshalPublicKey,
  randomBytes,
  require_aes,
  require_asn1,
  require_des,
  require_forge,
  require_md,
  require_minimal,
  require_oids,
  require_pbe,
  require_pbkdf2,
  require_pem,
  require_random,
  require_reader,
  require_reader_buffer,
  require_rsa,
  require_util,
  require_writer,
  require_writer_buffer,
  unmarshalPrivateKey,
  unmarshalPublicKey,
  unsigned
} from "./chunk-FK6CQ3ZP.js";
import {
  require_any_signal,
  require_rate_limiter_flexible
} from "./chunk-J7R3FAMY.js";
import {
  Uint8ArrayList,
  pipe,
  require_fast_fifo,
  require_it_merge
} from "./chunk-CRB7ZAE2.js";
import {
  CustomEvent,
  EventEmitter,
  symbol
} from "./chunk-5CSHHXSA.js";
import {
  isPeerId,
  peerIdFromBytes,
  peerIdFromKeys,
  peerIdFromPeerId,
  peerIdFromString
} from "./chunk-WOWDF62C.js";
import {
  pushable
} from "./chunk-I6BFH7TY.js";
import {
  AbortError,
  isBrowser,
  isElectronMain,
  isElectronRenderer,
  isNode,
  isReactNative,
  isWebWorker,
  pTimeout
} from "./chunk-NMMUCCGU.js";
import {
  symbol as symbol2
} from "./chunk-V5NN7TXM.js";
import "./chunk-GYD5GS2D.js";
import {
  Circuit,
  fromNodeAddress,
  getProtocol,
  isMultiaddr,
  multiaddr,
  resolvers
} from "./chunk-EWRST3T5.js";
import {
  abortableDuplex,
  abortableSource
} from "./chunk-BUAMSZU7.js";
import "./chunk-RZC6SFPH.js";
import {
  CID,
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM,
  base32,
  bases,
  logger,
  require_browser,
  require_err_code,
  require_ms,
  sha256
} from "./chunk-WITB7XN5.js";

// node_modules/datastore-core/node_modules/it-all/index.js
var require_it_all = __commonJS({
  "node_modules/datastore-core/node_modules/it-all/index.js"(exports, module) {
    "use strict";
    var all4 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module.exports = all4;
  }
});

// node_modules/datastore-core/node_modules/it-drain/index.js
var require_it_drain = __commonJS({
  "node_modules/datastore-core/node_modules/it-drain/index.js"(exports, module) {
    "use strict";
    var drain3 = async (source) => {
      for await (const _ of source) {
      }
    };
    module.exports = drain3;
  }
});

// node_modules/datastore-core/node_modules/it-filter/index.js
var require_it_filter = __commonJS({
  "node_modules/datastore-core/node_modules/it-filter/index.js"(exports, module) {
    "use strict";
    var filter4 = async function* (source, fn) {
      for await (const entry of source) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    };
    module.exports = filter4;
  }
});

// node_modules/it-take/index.js
var require_it_take = __commonJS({
  "node_modules/it-take/index.js"(exports, module) {
    "use strict";
    var take2 = async function* (source, limit) {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    };
    module.exports = take2;
  }
});

// node_modules/retimer/time-browser.js
var require_time_browser = __commonJS({
  "node_modules/retimer/time-browser.js"(exports, module) {
    "use strict";
    module.exports = function getTime() {
      return Date.now();
    };
  }
});

// node_modules/retimer/retimer.js
var require_retimer = __commonJS({
  "node_modules/retimer/retimer.js"(exports, module) {
    "use strict";
    var getTime = require_time_browser();
    var Retimer = class {
      constructor(callback, timeout, args) {
        const that = this;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._args = args;
        this._triggered = false;
        this._timerWrapper = () => {
          if (that._rescheduled > 0) {
            that._scheduled = that._rescheduled - (getTime() - that._started);
            that._schedule(that._scheduled);
          } else {
            that._triggered = true;
            callback.apply(null, that._args);
          }
        };
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      reschedule(timeout) {
        if (!timeout) {
          timeout = this._scheduled;
        }
        const now = getTime();
        if (now + timeout - (this._started + this._scheduled) < 0) {
          clearTimeout(this._timer);
          this._schedule(timeout);
        } else if (!this._triggered) {
          this._started = now;
          this._rescheduled = timeout;
        } else {
          this._schedule(timeout);
        }
      }
      _schedule(timeout) {
        this._triggered = false;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      clear() {
        clearTimeout(this._timer);
      }
    };
    function retimer4() {
      if (typeof arguments[0] !== "function") {
        throw new Error("callback needed");
      }
      if (typeof arguments[1] !== "number") {
        throw new Error("timeout needed");
      }
      let args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 2];
        }
      }
      return new Retimer(arguments[0], arguments[1], args);
    }
    module.exports = retimer4;
  }
});

// node_modules/timeout-abort-controller/index.js
var require_timeout_abort_controller = __commonJS({
  "node_modules/timeout-abort-controller/index.js"(exports, module) {
    "use strict";
    var { AbortController: AbortController2 } = globalThis;
    var retimer4 = require_retimer();
    var TimeoutController9 = class extends AbortController2 {
      constructor(ms) {
        super();
        this._ms = ms;
        this._timer = retimer4(() => this.abort(), ms);
        Object.setPrototypeOf(this, TimeoutController9.prototype);
      }
      abort() {
        this._timer.clear();
        return super.abort();
      }
      clear() {
        this._timer.clear();
      }
      reset() {
        this._timer.clear();
        this._timer = retimer4(() => this.abort(), this._ms);
      }
    };
    module.exports = {
      TimeoutController: TimeoutController9
    };
  }
});

// node_modules/set-delayed-interval/src/index.js
var require_src = __commonJS({
  "node_modules/set-delayed-interval/src/index.js"(exports, module) {
    "use strict";
    var intervals = /* @__PURE__ */ new Map();
    var _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
    async function _runPeriodically(task, interval, id) {
      while (intervals.get(id)) {
        try {
          await task();
        } catch (err) {
          setTimeout(() => {
            throw err;
          }, 1);
          break;
        }
        if (!intervals.get(id)) {
          break;
        }
        await new Promise((resolve) => {
          const _timeout = setTimeout(resolve, interval);
          intervals.set(id, _timeout);
        });
      }
    }
    function setDelayedInterval3(task, interval, delay) {
      delay = delay || interval;
      const id = _generateId();
      const _timeout = setTimeout(() => {
        _runPeriodically(task, interval, id);
      }, delay);
      intervals.set(id, _timeout);
      return id;
    }
    function clearDelayedInterval3(id) {
      const _timeout = intervals.get(id);
      if (_timeout) {
        clearTimeout(_timeout);
        intervals.delete(id);
      }
    }
    module.exports = {
      setDelayedInterval: setDelayedInterval3,
      clearDelayedInterval: clearDelayedInterval3
    };
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners10(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter3.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports, module) {
    "use strict";
    module.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports, module) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name2, value) => Object.defineProperty(object, name2, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol4 of symbols) {
          if (propertyIsEnumerable.call(value, symbol4)) {
            keys.push(symbol4);
          }
        }
      }
      return keys;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge3(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
      });
      return result;
    };
    function merge3(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    module.exports = function(...options) {
      const config = merge3(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge3(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports) {
    (function() {
      var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s) {
        var base, dmax, i, n, start;
        n = 0;
        base = 10;
        dmax = "9";
        i = 0;
        if (s.length > 1 && s[i] === "0") {
          if (s[i + 1] === "x" || s[i + 1] === "X") {
            i += 2;
            base = 16;
          } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
            i++;
            base = 8;
            dmax = "7";
          }
        }
        start = i;
        while (i < s.length) {
          if ("0" <= s[i] && s[i] <= dmax) {
            n = n * base + (chr(s[i]) - chr0) >>> 0;
          } else if (base === 16) {
            if ("a" <= s[i] && s[i] <= "f") {
              n = n * base + (10 + chr(s[i]) - chra) >>> 0;
            } else if ("A" <= s[i] && s[i] <= "F") {
              n = n * base + (10 + chr(s[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start) {
          throw new Error("empty octet");
        }
        return [n, i];
      };
      Netmask = function() {
        function Netmask2(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask2.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask2(ip);
          }
          if (ip instanceof Netmask2) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask2.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask2.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask2.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask2;
      }();
      exports.ip2long = ip2long;
      exports.long2ip = long2ip;
      exports.Netmask = Netmask;
    }).call(exports);
  }
});

// node_modules/private-ip/node_modules/ip-regex/index.js
var require_ip_regex = __commonJS({
  "node_modules/private-ip/node_modules/ip-regex/index.js"(exports, module) {
    "use strict";
    var word = "[a-fA-F\\d:]";
    var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
    var v4exact = new RegExp(`^${v4}$`);
    var v6exact = new RegExp(`^${v6}$`);
    var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
    ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
    ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
    module.exports = ip;
  }
});

// node_modules/private-ip/node_modules/is-ip/index.js
var require_is_ip = __commonJS({
  "node_modules/private-ip/node_modules/is-ip/index.js"(exports, module) {
    "use strict";
    var ipRegex = require_ip_regex();
    var isIp = (string6) => ipRegex({ exact: true }).test(string6);
    isIp.v4 = (string6) => ipRegex.v4({ exact: true }).test(string6);
    isIp.v6 = (string6) => ipRegex.v6({ exact: true }).test(string6);
    isIp.version = (string6) => isIp(string6) ? isIp.v4(string6) ? 4 : 6 : void 0;
    module.exports = isIp;
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports, module) {
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string6, parts) {
        if (string6.indexOf("::") !== string6.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string6.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string6 = string6.replace(/%.+$/, "");
        }
        while ((lastColon = string6.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string6.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string6.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string6 = string6.replace("::", replacement);
        if (string6[0] === ":") {
          string6 = string6.slice(1);
        }
        if (string6[string6.length - 1] === ":") {
          string6 = string6.slice(0, -1);
        }
        parts = function() {
          const ref = string6.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first3, second, partSize, cidrBits) {
        if (first3.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first3[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string6) {
        if (hexRegex.test(string6)) {
          return parseInt(string6, 16);
        }
        if (string6[0] === "0" && !isNaN(parseInt(string6[1], 10))) {
          if (octalRegex.test(string6)) {
            return parseInt(string6, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string6} as octal`);
        }
        return parseInt(string6, 10);
      }
      function padPart(part, length) {
        while (part.length < length) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr = {};
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop2 = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop2 && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop2 = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string6) {
        try {
          const cidr = this.parseCIDR(string6);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string6) {
        return this.parser(string6) !== null;
      };
      ipaddr.IPv4.isValid = function(string6) {
        try {
          new this(this.parser(string6));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string6) {
        if (ipaddr.IPv4.isValid(string6) && string6.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string6) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string6);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string6) {
        const parts = this.parser(string6);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string6) {
        let match;
        if (match = string6.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string6) {
        let match, part, value;
        if (match = string6.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string6.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string6.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string6.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop2 = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop2 && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop2 = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string6 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string6)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string6;
          }
          return `${string6.substring(0, bestMatchIndex)}::${string6.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        return IPv6;
      }();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string6) {
        try {
          const cidr = this.parseCIDR(string6);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string6) {
        return this.parser(string6) !== null;
      };
      ipaddr.IPv6.isValid = function(string6) {
        if (typeof string6 === "string" && string6.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string6);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string6) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string6);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.parse = function(string6) {
        const addr = this.parser(string6);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string6) {
        let maskLength, match, parsed;
        if (match = string6.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string6) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string6.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string6)) {
          return expandIPv6(string6, 8);
        }
        if (match = string6.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes) {
        const length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string6) {
        return ipaddr.IPv6.isValid(string6) || ipaddr.IPv4.isValid(string6);
      };
      ipaddr.parse = function(string6) {
        if (ipaddr.IPv6.isValid(string6)) {
          return ipaddr.IPv6.parse(string6);
        } else if (ipaddr.IPv4.isValid(string6)) {
          return ipaddr.IPv4.parse(string6);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string6) {
        try {
          return ipaddr.IPv6.parseCIDR(string6);
        } catch (e) {
          try {
            return ipaddr.IPv4.parseCIDR(string6);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string6) {
        const addr = this.parse(string6);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = ipaddr;
      } else {
        root.ipaddr = ipaddr;
      }
    })(exports);
  }
});

// node_modules/private-ip/lib/index.js
var require_lib = __commonJS({
  "node_modules/private-ip/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var netmask_1 = require_netmask();
    var ip_regex_1 = __importDefault(require_ip_regex());
    var is_ip_1 = __importDefault(require_is_ip());
    var ipaddr_js_1 = require_ipaddr();
    var PRIVATE_IP_RANGES = [
      "0.0.0.0/8",
      "10.0.0.0/8",
      "100.64.0.0/10",
      "127.0.0.0/8",
      "169.254.0.0/16",
      "172.16.0.0/12",
      "192.0.0.0/24",
      "192.0.0.0/29",
      "192.0.0.8/32",
      "192.0.0.9/32",
      "192.0.0.10/32",
      "192.0.0.170/32",
      "192.0.0.171/32",
      "192.0.2.0/24",
      "192.31.196.0/24",
      "192.52.193.0/24",
      "192.88.99.0/24",
      "192.168.0.0/16",
      "192.175.48.0/24",
      "198.18.0.0/15",
      "198.51.100.0/24",
      "203.0.113.0/24",
      "240.0.0.0/4",
      "255.255.255.255/32"
    ];
    var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new netmask_1.Netmask(ip_range));
    function ipv4_check(ip_addr) {
      for (let r of NETMASK_RANGES) {
        if (r.contains(ip_addr))
          return true;
      }
      return false;
    }
    function ipv6_check(ip_addr) {
      return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
    }
    exports.default = (ip) => {
      if ((0, ipaddr_js_1.isValid)(ip)) {
        const parsed = (0, ipaddr_js_1.parse)(ip);
        if (parsed.kind() === "ipv4")
          return ipv4_check(parsed.toNormalizedString());
        else if (parsed.kind() === "ipv6")
          return ipv6_check(ip);
      } else if ((0, is_ip_1.default)(ip) && ip_regex_1.default.v6().test(ip))
        return ipv6_check(ip);
      return void 0;
    };
  }
});

// node_modules/private-ip/index.js
var require_private_ip = __commonJS({
  "node_modules/private-ip/index.js"(exports, module) {
    "use strict";
    module.exports = require_lib().default;
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports, module) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function truncate(getLength, string6, byteLength) {
      if (typeof string6 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string6.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string6.charCodeAt(i);
        segment = string6[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string6.charCodeAt(i + 1))) {
          i += 1;
          segment += string6[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string6.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string6.slice(0, i - segment.length + 1);
        }
      }
      return string6;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser2 = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports, module) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module.exports = function getByteLength(string6) {
      if (typeof string6 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string6.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string6.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser3 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports, module) {
    "use strict";
    var truncate = require_truncate();
    var getLength = require_browser2();
    module.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports, module) {
    "use strict";
    var truncate = require_browser3();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output = sanitize2(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize2(output, "");
    };
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports, module) {
    var forge4 = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge4.asn1;
    var p7v = module.exports = forge4.pkcs7asn1 = forge4.pkcs7asn1 || {};
    forge4.pkcs7 = forge4.pkcs7 || {};
    forge4.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports, module) {
    var forge4 = require_forge();
    require_util();
    forge4.mgf = forge4.mgf || {};
    var mgf1 = module.exports = forge4.mgf.mgf1 = forge4.mgf1 = forge4.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        generate: function(seed, maskLen) {
          var t = new forge4.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge4.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports, module) {
    var forge4 = require_forge();
    require_mgf1();
    module.exports = forge4.mgf = forge4.mgf || {};
    forge4.mgf.mgf1 = forge4.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports, module) {
    var forge4 = require_forge();
    require_random();
    require_util();
    var pss = module.exports = forge4.pss = forge4.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash = options.md;
      var mgf = options.mgf;
      var hLen = hash.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge4.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge4.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge4.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h = hash.digest().getBytes();
        var ps = new forge4.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen; i++) {
          if (db.charCodeAt(i) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge4.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash.start();
        hash.update(m_.getBytes());
        var h_ = hash.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports, module) {
    var forge4 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge4.asn1;
    var pki2 = module.exports = forge4.pki = forge4.pki || {};
    var oids = pki2.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge4.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          publicKeyValidator,
          {
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki2.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i = 0; i < set.value.length; ++i) {
          obj = {};
          attr = set.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki2.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge4.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge4.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge4.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge4.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge4.md.sha512.create();
        case "RSASSA-PSS":
          return forge4.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash, mgf;
          hash = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash === void 0 || forge4.md[hash] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge4.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge4.mgf[mgf].create(forge4.md[hash].create());
          hash = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash === void 0 || forge4.md[hash] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash;
            throw error;
          }
          scheme = forge4.pss.create(
            forge4.md[hash].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki2.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificateFromAsn1(obj, computeHash);
    };
    pki2.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki2.certificateToAsn1(cert)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki2.publicKeyFromPem = function(pem) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki2.publicKeyFromAsn1(obj);
    };
    pki2.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki2.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge4.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes;
      switch (type) {
        case "RSAPublicKey":
          bytes = asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes = asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes);
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki2.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki2.certificationRequestFromAsn1(obj, computeHash);
    };
    pki2.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge4.pem.encode(msg, { maxline });
    };
    pki2.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
          ext = cert.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge4.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki2.getTBSCertificate(cert);
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki2.getTBSCertificate(child);
          var bytes = asn1.toDer(tbsCertificate);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i = cert.issuer;
        var s = parent.subject;
        if (i.hash && s.hash) {
          rval = i.hash === s.hash;
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i = 0; i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge4.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki2.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki2.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge4.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge4.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge4.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
      }
      var imd = forge4.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge4.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki2.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki2.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge4.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge4.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki2.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki2.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki2.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge4.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge4.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge4.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki2.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki2.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki2.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge4.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(cri);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge4.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki2.oids) {
            attr.name = pki2.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki2.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki2.oids) {
            attr.type = pki2.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki2.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki2.oids) {
          e.name = pki2.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki2.oids) {
          e.id = pki2.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge4.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge4.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge4.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge4.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki2.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge4.util.hexToBytes(cert.serialNumber)
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        _dnToAsn1(cert.issuer),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        _dnToAsn1(cert.subject),
        pki2.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki2.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        _dnToAsn1(csr.subject),
        pki2.publicKeyToAsn1(csr.publicKey),
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki2.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki2.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki2.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        tbsCertificate,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki2.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki2.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki2.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value
      ));
      return extseq;
    };
    pki2.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        cri,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki2.createCaStore = function(certs) {
      var caStore = {
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge4.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge4.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge4.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge4.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash)) {
            var value = caStore.certs[hash];
            if (!forge4.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i2 = 0; i2 < value.length; ++i2) {
                certList.push(value[i2]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge4.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge4.util.isArray(match)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki2.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            result = match[i2];
            match.splice(i2, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge4.md.sha1.create();
          subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert = certs[i];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki2.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki2.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = new Date();
      }
      var first3 = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki2.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent = chain[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge4.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki2.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent && !cert.isIssuer(parent)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki2.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error === null && i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki2.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first3 || chain.length === 0 && (!parent || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki2.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki2.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge4.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first3 = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports, module) {
    var forge4 = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge4.asn1;
    var p7 = module.exports = forge4.pkcs7 = forge4.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge4.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge4.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge4.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge4.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge4.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge4.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i = 0; i < certs.length; ++i) {
              msg.certificates.push(forge4.pki.certificateFromAsn1(certs[i]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge4.pki.certificateToAsn1(msg.certificates[i]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              signedData
            ]
          );
        },
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge4.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge4.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge4.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge4.pki.oids.sha1:
            case forge4.pki.oids.sha256:
            case forge4.pki.oids.sha384:
            case forge4.pki.oids.sha512:
            case forge4.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i = 0; i < authenticatedAttributes.length; ++i) {
              var attr = authenticatedAttributes[i];
              if (!contentType && attr.type === forge4.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge4.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge4.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge4.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge4.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge4.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge4.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge4.md[forge4.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge4.md[forge4.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes = asn1.toDer(content);
        bytes.getByte();
        asn1.getBerValueLength(bytes);
        bytes = bytes.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes);
        }
        var signingTime = new Date();
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge4.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge4.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge4.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge4.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge4.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge4.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge4.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r = msg.recipients[i];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge4.pki.oids.rsaEncryption:
              case forge4.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge4.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              algorithm: forge4.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge4.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge4.aes.createEncryptionCipher;
                break;
              case forge4.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge4.aes.createEncryptionCipher;
                break;
              case forge4.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge4.aes.createEncryptionCipher;
                break;
              case forge4.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge4.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge4.util.createBuffer(forge4.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge4.util.createBuffer(
              forge4.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; ++i) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge4.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge4.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge4.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge4.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge4.util.hexToBytes(obj.serialNumber)
          )
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i = 0; i < infos.length; ++i) {
        ret.push(_recipientFromAsn1(infos[i]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i = 0; i < recipients.length; ++i) {
        ret.push(_recipientToAsn1(recipients[i]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge4.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge4.util.hexToBytes(obj.serialNumber)
          )
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
          var attr = obj.unauthenticatedAttributes[i];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i = 0; i < signers.length; ++i) {
        ret.push(_signerToAsn1(signers[i]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge4.pki.oids.contentType) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge4.pki.oids.messageDigest) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge4.pki.oids.signingTime) {
        var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge4.pki.oids.data).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge4.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge4.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge4.util.createBuffer(capture.encParameter.value),
          content: forge4.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge4.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge4.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge4.pki.oids["aes128-CBC"]:
          case forge4.pki.oids["aes192-CBC"]:
          case forge4.pki.oids["aes256-CBC"]:
            ciph = forge4.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge4.pki.oids["desCBC"]:
          case forge4.pki.oids["des-EDE3-CBC"]:
            ciph = forge4.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports, module) {
    module.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache = /* @__PURE__ */ Object.create(null), _cache = /* @__PURE__ */ Object.create(null);
      function update(key, value) {
        cache[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache;
          cache = /* @__PURE__ */ Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache[key] !== void 0)
            cache[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache[key] !== void 0)
            cache[key] = value;
          else
            update(key, value);
        },
        clear: function() {
          cache = /* @__PURE__ */ Object.create(null);
          _cache = /* @__PURE__ */ Object.create(null);
        }
      };
    };
  }
});

// node_modules/@libp2p/multistream-select/node_modules/it-first/index.js
var require_it_first = __commonJS({
  "node_modules/@libp2p/multistream-select/node_modules/it-first/index.js"(exports, module) {
    "use strict";
    var first3 = async (source) => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    };
    module.exports = first3;
  }
});

// node_modules/mutable-proxy/build/index.js
var require_build = __commonJS({
  "node_modules/mutable-proxy/build/index.js"(exports, module) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module.exports = function mutableProxyFactory(defaultTarget) {
      var mutableHandler = void 0;
      var mutableTarget = void 0;
      function setTarget(target) {
        if (!(target instanceof Object)) {
          throw new Error('Target "' + target + '" is not an object');
        }
        mutableTarget = target;
      }
      function setHandler(handler2) {
        Object.keys(handler2).forEach(function(key) {
          var value = handler2[key];
          if (typeof value !== "function") {
            throw new Error('Trap "' + key + ": " + value + '" is not a function');
          }
          if (!Reflect[key]) {
            throw new Error('Trap "' + key + ": " + value + '" is not a valid trap');
          }
        });
        mutableHandler = handler2;
      }
      setTarget(function() {
      });
      if (defaultTarget) {
        setTarget(defaultTarget);
      }
      setHandler(Reflect);
      var handler = new Proxy({}, {
        get: function get(target, property) {
          return function() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
          };
        }
      });
      return {
        setTarget,
        setHandler,
        getTarget: function getTarget() {
          return mutableTarget;
        },
        getHandler: function getHandler() {
          return mutableHandler;
        },
        proxy: new Proxy(mutableTarget, handler)
      };
    };
  }
});

// node_modules/@libp2p/peer-store/node_modules/it-all/index.js
var require_it_all2 = __commonJS({
  "node_modules/@libp2p/peer-store/node_modules/it-all/index.js"(exports, module) {
    "use strict";
    var all4 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module.exports = all4;
  }
});

// node_modules/@libp2p/peer-store/node_modules/it-filter/index.js
var require_it_filter2 = __commonJS({
  "node_modules/@libp2p/peer-store/node_modules/it-filter/index.js"(exports, module) {
    "use strict";
    var filter4 = async function* (source, fn) {
      for await (const entry of source) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    };
    module.exports = filter4;
  }
});

// node_modules/@libp2p/peer-store/node_modules/it-map/index.js
var require_it_map = __commonJS({
  "node_modules/@libp2p/peer-store/node_modules/it-map/index.js"(exports, module) {
    "use strict";
    var map3 = async function* (source, func) {
      for await (const val of source) {
        yield func(val);
      }
    };
    module.exports = map3;
  }
});

// node_modules/@libp2p/peer-store/node_modules/it-foreach/index.js
var require_it_foreach = __commonJS({
  "node_modules/@libp2p/peer-store/node_modules/it-foreach/index.js"(exports, module) {
    "use strict";
    var each2 = async function* (source, fn) {
      for await (const thing of source) {
        await fn(thing);
        yield thing;
      }
    };
    module.exports = each2;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events2, name2;
      if (this._eventsCount === 0)
        return names;
      for (name2 in events2 = this._events) {
        if (has.call(events2, name2))
          names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events2.push(listeners[i]);
          }
        }
        if (events2.length)
          this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/receptacle/index.js
var require_receptacle = __commonJS({
  "node_modules/receptacle/index.js"(exports, module) {
    "use strict";
    module.exports = Receptacle2;
    var toMS = require_ms();
    var cache = Receptacle2.prototype;
    var counter = new Date() % 1e9;
    function getUID() {
      return (Math.random() * 1e9 >>> 0) + counter++;
    }
    function Receptacle2(options) {
      options = options || {};
      this.id = options.id || getUID();
      this.max = options.max || Infinity;
      this.items = options.items || [];
      this._lookup = {};
      this.size = this.items.length;
      this.lastModified = new Date(options.lastModified || new Date());
      for (var item, ttl, i = this.items.length; i--; ) {
        item = this.items[i];
        ttl = new Date(item.expires) - new Date();
        this._lookup[item.key] = item;
        if (ttl > 0)
          this.expire(item.key, ttl);
        else if (ttl <= 0)
          this.delete(item.key);
      }
    }
    cache.has = function(key) {
      return key in this._lookup;
    };
    cache.get = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (record.refresh)
        this.expire(key, record.refresh);
      this.items.splice(this.items.indexOf(record), 1);
      this.items.push(record);
      return record.value;
    };
    cache.meta = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (!("meta" in record))
        return null;
      return record.meta;
    };
    cache.set = function(key, value, options) {
      var oldRecord = this._lookup[key];
      var record = this._lookup[key] = { key, value };
      this.lastModified = new Date();
      if (oldRecord) {
        clearTimeout(oldRecord.timeout);
        this.items.splice(this.items.indexOf(oldRecord), 1, record);
      } else {
        if (this.size >= this.max)
          this.delete(this.items[0].key);
        this.items.push(record);
        this.size++;
      }
      if (options) {
        if ("ttl" in options)
          this.expire(key, options.ttl);
        if ("meta" in options)
          record.meta = options.meta;
        if (options.refresh)
          record.refresh = options.ttl;
      }
      return this;
    };
    cache.delete = function(key) {
      var record = this._lookup[key];
      if (!record)
        return false;
      this.lastModified = new Date();
      this.items.splice(this.items.indexOf(record), 1);
      clearTimeout(record.timeout);
      delete this._lookup[key];
      this.size--;
      return this;
    };
    cache.expire = function(key, ttl) {
      var ms = ttl || 0;
      var record = this._lookup[key];
      if (!record)
        return this;
      if (typeof ms === "string")
        ms = toMS(ttl);
      if (typeof ms !== "number")
        throw new TypeError("Expiration time must be a string or number.");
      clearTimeout(record.timeout);
      record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
      record.expires = Number(new Date()) + ms;
      return this;
    };
    cache.clear = function() {
      for (var i = this.items.length; i--; )
        this.delete(this.items[i].key);
      return this;
    };
    cache.toJSON = function() {
      var items = new Array(this.items.length);
      var item;
      for (var i = items.length; i--; ) {
        item = this.items[i];
        items[i] = {
          key: item.key,
          meta: item.meta,
          value: item.value,
          expires: item.expires,
          refresh: item.refresh
        };
      }
      return {
        id: this.id,
        max: isFinite(this.max) ? this.max : void 0,
        lastModified: this.lastModified,
        items
      };
    };
  }
});

// node_modules/p-fifo/node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "node_modules/p-fifo/node_modules/p-defer/index.js"(exports, module) {
    "use strict";
    var pDefer = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve, reject) => {
        deferred.resolve = resolve;
        deferred.reject = reject;
      });
      return deferred;
    };
    module.exports = pDefer;
  }
});

// node_modules/p-fifo/index.js
var require_p_fifo = __commonJS({
  "node_modules/p-fifo/index.js"(exports, module) {
    var Fifo = require_fast_fifo();
    var defer = require_p_defer();
    module.exports = class PFifo {
      constructor() {
        this._buffer = new Fifo();
        this._waitingConsumers = new Fifo();
      }
      push(chunk) {
        const { promise, resolve } = defer();
        this._buffer.push({ chunk, resolve });
        this._consume();
        return promise;
      }
      _consume() {
        while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
          const nextConsumer = this._waitingConsumers.shift();
          const nextChunk = this._buffer.shift();
          nextConsumer.resolve(nextChunk.chunk);
          nextChunk.resolve();
        }
      }
      shift() {
        const { promise, resolve } = defer();
        this._waitingConsumers.push({ resolve });
        this._consume();
        return promise;
      }
      isEmpty() {
        return this._buffer.isEmpty();
      }
    };
  }
});

// node_modules/@libp2p/interfaces/dist/src/startable.js
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}

// node_modules/datastore-core/src/utils.js
var import_it_all = __toESM(require_it_all(), 1);
var sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await (0, import_it_all.default)(iterable);
    yield* values.sort(sorter);
  }();
};

// node_modules/datastore-core/src/base.js
var import_it_drain = __toESM(require_it_drain(), 1);
var import_it_filter = __toESM(require_it_filter(), 1);
var import_it_take = __toESM(require_it_take(), 1);
var BaseDatastore = class {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield { key, value };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await (0, import_it_drain.default)(this.putMany(puts, options));
        puts = [];
        await (0, import_it_drain.default)(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter.default)(
        it,
        (e) => e.key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = (0, import_it_filter.default)(
        it,
        (key) => key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i = 0;
      it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
    }
    if (q.limit != null) {
      it = (0, import_it_take.default)(it, q.limit);
    }
    return it;
  }
};

// node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec(name2, prefix, encode3, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: {
      decode: decode2
    }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string6 = "a";
  for (let i = 0; i < buf.length; i++) {
    string6 += String.fromCharCode(buf[i]);
  }
  return string6;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/to-string.js
function toString(array, encoding = "utf8") {
  const base = bases_default[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base.encoder.encode(array).substring(1);
}

// node_modules/interface-datastore/node_modules/uint8arrays/dist/src/from-string.js
function fromString(string6, encoding = "utf8") {
  const base = bases_default[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string6, "utf-8"));
  }
  return base.decoder.decode(`${base.prefix}${string6}`);
}

// node_modules/interface-datastore/dist/src/key.js
var pathSepS = "/";
var pathSepB = new TextEncoder().encode(pathSepS);
var pathSep = pathSepB[0];
var Key = class {
  constructor(s, clean) {
    if (typeof s === "string") {
      this._buf = fromString(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  toString(encoding = "utf8") {
    return toString(this._buf, encoding);
  }
  uint8Array() {
    return this._buf;
  }
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  static withNamespaces(list) {
    return new Key(list.join(pathSepS));
  }
  static random() {
    return new Key(nanoid().replace(/-/g, ""));
  }
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new Key(other.uint8Array());
    }
    return null;
  }
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes = new Uint8Array(this._buf.byteLength + 1);
      bytes.fill(pathSep, 0, 1);
      bytes.set(this._buf, 1);
      this._buf = bytes;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i = 0; i < list1.length; i++) {
      if (list2.length < i + 1) {
        return false;
      }
      const c1 = list1[i];
      const c2 = list2[i];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  namespaces() {
    return this.list();
  }
  baseNamespace() {
    const ns = this.namespaces();
    return ns[ns.length - 1];
  }
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  type() {
    return namespaceType(this.baseNamespace());
  }
  name() {
    return namespaceValue(this.baseNamespace());
  }
  instance(s) {
    return new Key(this.toString() + ":" + s);
  }
  path() {
    let p = this.parent().toString();
    if (!p.endsWith(pathSepS)) {
      p += pathSepS;
    }
    p += this.type();
    return new Key(p);
  }
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new Key(pathSepS);
    }
    return new Key(list.slice(0, -1).join(pathSepS));
  }
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new Key(this.toString() + key.toString(), false);
  }
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  isTopLevel() {
    return this.list().length === 1;
  }
  concat(...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
};
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}

// node_modules/datastore-core/src/errors.js
var import_err_code = __toESM(require_err_code(), 1);
function notFoundError(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code.default)(err, "ERR_NOT_FOUND");
}

// node_modules/datastore-core/src/memory.js
var MemoryDatastore = class extends BaseDatastore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  async put(key, val) {
    this.data[key.toString()] = val;
  }
  async get(key) {
    const exists = await this.has(key);
    if (!exists)
      throw notFoundError();
    return this.data[key.toString()];
  }
  async has(key) {
    return this.data[key.toString()] !== void 0;
  }
  async delete(key) {
    delete this.data[key.toString()];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value]) => ({ key: new Key(key), value }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => new Key(key));
  }
};

// node_modules/libp2p/dist/src/peer-routing.js
var import_err_code3 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/errors.js
var messages;
(function(messages2) {
  messages2["NOT_STARTED_YET"] = "The libp2p node is not started yet";
  messages2["DHT_DISABLED"] = "DHT is not available";
  messages2["PUBSUB_DISABLED"] = "PubSub is not available";
  messages2["CONN_ENCRYPTION_REQUIRED"] = "At least one connection encryption module is required";
  messages2["ERR_TRANSPORTS_REQUIRED"] = "At least one transport module is required";
  messages2["ERR_PROTECTOR_REQUIRED"] = "Private network is enforced, but no protector was provided";
  messages2["NOT_FOUND"] = "Not found";
})(messages || (messages = {}));
var codes;
(function(codes4) {
  codes4["DHT_DISABLED"] = "ERR_DHT_DISABLED";
  codes4["ERR_PUBSUB_DISABLED"] = "ERR_PUBSUB_DISABLED";
  codes4["PUBSUB_NOT_STARTED"] = "ERR_PUBSUB_NOT_STARTED";
  codes4["DHT_NOT_STARTED"] = "ERR_DHT_NOT_STARTED";
  codes4["CONN_ENCRYPTION_REQUIRED"] = "ERR_CONN_ENCRYPTION_REQUIRED";
  codes4["ERR_TRANSPORTS_REQUIRED"] = "ERR_TRANSPORTS_REQUIRED";
  codes4["ERR_PROTECTOR_REQUIRED"] = "ERR_PROTECTOR_REQUIRED";
  codes4["ERR_PEER_DIAL_INTERCEPTED"] = "ERR_PEER_DIAL_INTERCEPTED";
  codes4["ERR_CONNECTION_INTERCEPTED"] = "ERR_CONNECTION_INTERCEPTED";
  codes4["ERR_INVALID_PROTOCOLS_FOR_STREAM"] = "ERR_INVALID_PROTOCOLS_FOR_STREAM";
  codes4["ERR_CONNECTION_ENDED"] = "ERR_CONNECTION_ENDED";
  codes4["ERR_CONNECTION_FAILED"] = "ERR_CONNECTION_FAILED";
  codes4["ERR_NODE_NOT_STARTED"] = "ERR_NODE_NOT_STARTED";
  codes4["ERR_ALREADY_ABORTED"] = "ERR_ALREADY_ABORTED";
  codes4["ERR_TOO_MANY_ADDRESSES"] = "ERR_TOO_MANY_ADDRESSES";
  codes4["ERR_NO_VALID_ADDRESSES"] = "ERR_NO_VALID_ADDRESSES";
  codes4["ERR_RELAYED_DIAL"] = "ERR_RELAYED_DIAL";
  codes4["ERR_DIALED_SELF"] = "ERR_DIALED_SELF";
  codes4["ERR_DISCOVERED_SELF"] = "ERR_DISCOVERED_SELF";
  codes4["ERR_DUPLICATE_TRANSPORT"] = "ERR_DUPLICATE_TRANSPORT";
  codes4["ERR_ENCRYPTION_FAILED"] = "ERR_ENCRYPTION_FAILED";
  codes4["ERR_HOP_REQUEST_FAILED"] = "ERR_HOP_REQUEST_FAILED";
  codes4["ERR_INVALID_KEY"] = "ERR_INVALID_KEY";
  codes4["ERR_INVALID_MESSAGE"] = "ERR_INVALID_MESSAGE";
  codes4["ERR_INVALID_PARAMETERS"] = "ERR_INVALID_PARAMETERS";
  codes4["ERR_INVALID_PEER"] = "ERR_INVALID_PEER";
  codes4["ERR_MUXER_UNAVAILABLE"] = "ERR_MUXER_UNAVAILABLE";
  codes4["ERR_NOT_FOUND"] = "ERR_NOT_FOUND";
  codes4["ERR_TIMEOUT"] = "ERR_TIMEOUT";
  codes4["ERR_TRANSPORT_UNAVAILABLE"] = "ERR_TRANSPORT_UNAVAILABLE";
  codes4["ERR_TRANSPORT_DIAL_FAILED"] = "ERR_TRANSPORT_DIAL_FAILED";
  codes4["ERR_UNSUPPORTED_PROTOCOL"] = "ERR_UNSUPPORTED_PROTOCOL";
  codes4["ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED"] = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED";
  codes4["ERR_INVALID_MULTIADDR"] = "ERR_INVALID_MULTIADDR";
  codes4["ERR_SIGNATURE_NOT_VALID"] = "ERR_SIGNATURE_NOT_VALID";
  codes4["ERR_FIND_SELF"] = "ERR_FIND_SELF";
  codes4["ERR_NO_ROUTERS_AVAILABLE"] = "ERR_NO_ROUTERS_AVAILABLE";
  codes4["ERR_CONNECTION_NOT_MULTIPLEXED"] = "ERR_CONNECTION_NOT_MULTIPLEXED";
  codes4["ERR_NO_DIAL_TOKENS"] = "ERR_NO_DIAL_TOKENS";
  codes4["ERR_KEYCHAIN_REQUIRED"] = "ERR_KEYCHAIN_REQUIRED";
  codes4["ERR_INVALID_CMS"] = "ERR_INVALID_CMS";
  codes4["ERR_MISSING_KEYS"] = "ERR_MISSING_KEYS";
  codes4["ERR_NO_KEY"] = "ERR_NO_KEY";
  codes4["ERR_INVALID_KEY_NAME"] = "ERR_INVALID_KEY_NAME";
  codes4["ERR_INVALID_KEY_TYPE"] = "ERR_INVALID_KEY_TYPE";
  codes4["ERR_KEY_ALREADY_EXISTS"] = "ERR_KEY_ALREADY_EXISTS";
  codes4["ERR_INVALID_KEY_SIZE"] = "ERR_INVALID_KEY_SIZE";
  codes4["ERR_KEY_NOT_FOUND"] = "ERR_KEY_NOT_FOUND";
  codes4["ERR_OLD_KEY_NAME_INVALID"] = "ERR_OLD_KEY_NAME_INVALID";
  codes4["ERR_NEW_KEY_NAME_INVALID"] = "ERR_NEW_KEY_NAME_INVALID";
  codes4["ERR_PASSWORD_REQUIRED"] = "ERR_PASSWORD_REQUIRED";
  codes4["ERR_PEM_REQUIRED"] = "ERR_PEM_REQUIRED";
  codes4["ERR_CANNOT_READ_KEY"] = "ERR_CANNOT_READ_KEY";
  codes4["ERR_MISSING_PRIVATE_KEY"] = "ERR_MISSING_PRIVATE_KEY";
  codes4["ERR_MISSING_PUBLIC_KEY"] = "ERR_MISSING_PUBLIC_KEY";
  codes4["ERR_INVALID_OLD_PASS_TYPE"] = "ERR_INVALID_OLD_PASS_TYPE";
  codes4["ERR_INVALID_NEW_PASS_TYPE"] = "ERR_INVALID_NEW_PASS_TYPE";
  codes4["ERR_INVALID_PASS_LENGTH"] = "ERR_INVALID_PASS_LENGTH";
  codes4["ERR_NOT_IMPLEMENTED"] = "ERR_NOT_IMPLEMENTED";
  codes4["ERR_WRONG_PING_ACK"] = "ERR_WRONG_PING_ACK";
  codes4["ERR_INVALID_RECORD"] = "ERR_INVALID_RECORD";
  codes4["ERR_ALREADY_SUCCEEDED"] = "ERR_ALREADY_SUCCEEDED";
  codes4["ERR_NO_HANDLER_FOR_PROTOCOL"] = "ERR_NO_HANDLER_FOR_PROTOCOL";
  codes4["ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS";
  codes4["ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS"] = "ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS";
  codes4["ERR_CONNECTION_DENIED"] = "ERR_CONNECTION_DENIED";
})(codes || (codes = {}));

// node_modules/libp2p/dist/src/content-routing/utils.js
var import_err_code2 = __toESM(require_err_code(), 1);

// node_modules/it-filter/dist/src/index.js
async function* filter2(source, fn) {
  for await (const entry of source) {
    if (await fn(entry)) {
      yield entry;
    }
  }
}

// node_modules/it-map/dist/src/index.js
async function* map(source, func) {
  for await (const val of source) {
    yield func(val);
  }
}

// node_modules/libp2p/dist/src/content-routing/utils.js
async function* storeAddresses(source, peerStore) {
  yield* map(source, async (peer) => {
    await peerStore.addressBook.add(peer.id, peer.multiaddrs);
    return peer;
  });
}
function uniquePeers(source) {
  const seen = /* @__PURE__ */ new Set();
  return filter2(source, (peer) => {
    if (seen.has(peer.id.toString())) {
      return false;
    }
    seen.add(peer.id.toString());
    return true;
  });
}
async function* requirePeers(source, min = 1) {
  let seen = 0;
  for await (const peer of source) {
    seen++;
    yield peer;
  }
  if (seen < min) {
    throw (0, import_err_code2.default)(new Error("not found"), "NOT_FOUND");
  }
}

// node_modules/libp2p/dist/src/peer-routing.js
var import_timeout_abort_controller = __toESM(require_timeout_abort_controller(), 1);

// node_modules/libp2p/node_modules/it-merge/dist/src/index.js
async function* merge(...sources) {
  const output = pushable({
    objectMode: true
  });
  void Promise.resolve().then(async () => {
    try {
      await Promise.all(sources.map(async (source) => {
        for await (const item of source) {
          output.push(item);
        }
      }));
      output.end();
    } catch (err) {
      output.end(err);
    }
  });
  yield* output;
}

// node_modules/it-first/dist/src/index.js
async function first(source) {
  for await (const entry of source) {
    return entry;
  }
  return void 0;
}

// node_modules/it-drain/dist/src/index.js
async function drain2(source) {
  for await (const _ of source) {
  }
}

// node_modules/libp2p/dist/src/peer-routing.js
var import_set_delayed_interval = __toESM(require_src(), 1);
var import_events = __toESM(require_events(), 1);
var log = logger("libp2p:peer-routing");
var DefaultPeerRouting = class {
  constructor(components, init) {
    this.components = components;
    this.routers = init.routers;
    this.refreshManagerInit = init.refreshManager ?? {};
    this.started = false;
    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false) {
      return;
    }
    this.timeoutId = (0, import_set_delayed_interval.setDelayedInterval)(this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay);
    this.started = true;
  }
  async _findClosestPeersTask() {
    if (this.abortController != null) {
      return;
    }
    try {
      this.abortController = new import_timeout_abort_controller.TimeoutController(this.refreshManagerInit.timeout ?? 1e4);
      try {
        (0, import_events.setMaxListeners)?.(Infinity, this.abortController.signal);
      } catch {
      }
      await drain2(this.getClosestPeers(this.components.peerId.toBytes(), { signal: this.abortController.signal }));
    } catch (err) {
      log.error(err);
    } finally {
      this.abortController?.clear();
      this.abortController = void 0;
    }
  }
  async stop() {
    (0, import_set_delayed_interval.clearDelayedInterval)(this.timeoutId);
    this.abortController?.abort();
    this.started = false;
  }
  async findPeer(id, options) {
    if (this.routers.length === 0) {
      throw (0, import_err_code3.default)(new Error("No peer routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    if (id.toString() === this.components.peerId.toString()) {
      throw (0, import_err_code3.default)(new Error("Should not try to find self"), codes.ERR_FIND_SELF);
    }
    const output = await pipe(merge(...this.routers.map((router) => async function* () {
      try {
        yield await router.findPeer(id, options);
      } catch (err) {
        log.error(err);
      }
    }())), (source) => filter2(source, Boolean), (source) => storeAddresses(source, this.components.peerStore), async (source) => await first(source));
    if (output != null) {
      return output;
    }
    throw (0, import_err_code3.default)(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options) {
    if (this.routers.length === 0) {
      throw (0, import_err_code3.default)(new Error("No peer routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(merge(...this.routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
};

// node_modules/libp2p/dist/src/content-routing/index.js
var import_err_code4 = __toESM(require_err_code(), 1);
var CompoundContentRouting = class {
  constructor(components, init) {
    this.routers = init.routers ?? [];
    this.started = false;
    this.components = components;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  async *findProviders(key, options = {}) {
    if (this.routers.length === 0) {
      throw (0, import_err_code4.default)(new Error("No content this.routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    yield* pipe(merge(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
  }
  async provide(key, options = {}) {
    if (this.routers.length === 0) {
      throw (0, import_err_code4.default)(new Error("No content routers available"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    await Promise.all(this.routers.map(async (router) => await router.provide(key, options)));
  }
  async put(key, value, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code4.default)(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
    }
    const dht = this.components.dht;
    if (dht != null) {
      await drain2(dht.put(key, value, options));
    }
  }
  async get(key, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code4.default)(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
    }
    const dht = this.components.dht;
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          return event.value;
        }
      }
    }
    throw (0, import_err_code4.default)(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
  }
  async *getMany(key, nVals, options) {
    if (!this.isStarted()) {
      throw (0, import_err_code4.default)(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
    }
    if (nVals == null || nVals === 0) {
      return;
    }
    let gotValues = 0;
    const dht = this.components.dht;
    if (dht != null) {
      for await (const event of dht.get(key, options)) {
        if (event.name === "VALUE") {
          yield { from: event.from, val: event.value };
          gotValues++;
          if (gotValues === nVals) {
            break;
          }
        }
      }
    }
    if (gotValues === 0) {
      throw (0, import_err_code4.default)(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
    }
  }
};

// node_modules/libp2p/dist/src/get-peer.js
var import_err_code5 = __toESM(require_err_code(), 1);
function peerIdFromMultiaddr(ma) {
  const idStr = ma.getPeerId();
  if (idStr == null) {
    throw (0, import_err_code5.default)(new Error(`${ma.toString()} does not have a valid peer type`), codes.ERR_INVALID_MULTIADDR);
  }
  try {
    return peerIdFromString(idStr);
  } catch (err) {
    throw (0, import_err_code5.default)(new Error(`${ma.toString()} is not a valid peer type`), codes.ERR_INVALID_MULTIADDR);
  }
}
function getPeer(peer) {
  if (isPeerId(peer)) {
    return {
      id: peer,
      multiaddrs: [],
      protocols: []
    };
  }
  if (typeof peer === "string") {
    peer = multiaddr(peer);
  }
  let addr;
  if (isMultiaddr(peer)) {
    addr = peer;
    peer = peerIdFromMultiaddr(peer);
  }
  return {
    id: peer,
    multiaddrs: addr != null ? [addr] : [],
    protocols: []
  };
}

// node_modules/libp2p/dist/src/address-manager/index.js
var defaultAddressFilter = (addrs) => addrs;
var DefaultAddressManager = class extends EventEmitter {
  constructor(components, init) {
    super();
    const { listen = [], announce = [] } = init;
    this.components = components;
    this.listen = new Set(listen.map((ma) => ma.toString()));
    this.announce = new Set(announce.map((ma) => ma.toString()));
    this.observed = /* @__PURE__ */ new Set();
    this.announceFilter = init.announceFilter ?? defaultAddressFilter;
  }
  getListenAddrs() {
    return Array.from(this.listen).map((a) => multiaddr(a));
  }
  getAnnounceAddrs() {
    return Array.from(this.announce).map((a) => multiaddr(a));
  }
  getObservedAddrs() {
    return Array.from(this.observed).map((a) => multiaddr(a));
  }
  confirmObservedAddr(addr) {
  }
  removeObservedAddr(addr) {
  }
  addObservedAddr(addr) {
    let ma = multiaddr(addr);
    const remotePeer = ma.getPeerId();
    if (remotePeer != null) {
      const remotePeerId = peerIdFromString(remotePeer);
      if (remotePeerId.equals(this.components.peerId)) {
        ma = ma.decapsulate(multiaddr(`/p2p/${this.components.peerId.toString()}`));
      }
    }
    const addrString = ma.toString();
    if (this.observed.has(addrString)) {
      return;
    }
    this.observed.add(addrString);
    this.dispatchEvent(new CustomEvent("change:addresses"));
  }
  getAddresses() {
    let addrs = this.getAnnounceAddrs().map((ma) => ma.toString());
    if (addrs.length === 0) {
      addrs = this.components.transportManager.getAddrs().map((ma) => ma.toString());
    }
    addrs = addrs.concat(this.getObservedAddrs().map((ma) => ma.toString()));
    const addrSet = new Set(addrs);
    return this.announceFilter(Array.from(addrSet).map((str) => multiaddr(str))).map((ma) => {
      if (ma.getPeerId() === this.components.peerId.toString()) {
        return ma;
      }
      return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`);
    });
  }
};

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_err_code6 = __toESM(require_err_code(), 1);

// node_modules/merge-options/index.mjs
var import_index = __toESM(require_merge_options(), 1);
var merge_options_default = import_index.default;

// node_modules/libp2p/dist/src/connection-manager/visibility-change-emitter.js
var log2 = logger("libp2p:connection-manager:latency-monitor:visibility-change-emitter");
var VisibilityChangeEmitter = class extends EventEmitter {
  constructor() {
    super();
    this.hidden = "hidden";
    this.visibilityChange = "visibilityChange";
    if (globalThis.document != null) {
      this._initializeVisibilityVarNames();
      this._addVisibilityChangeListener();
    }
  }
  _initializeVisibilityVarNames() {
    let hidden = "hidden";
    let visibilityChange = "visibilitychange";
    if (typeof globalThis.document.hidden !== "undefined") {
      hidden = "hidden";
      visibilityChange = "visibilitychange";
    } else if (typeof globalThis.document.mozHidden !== "undefined") {
      hidden = "mozHidden";
      visibilityChange = "mozvisibilitychange";
    } else if (typeof globalThis.document.msHidden !== "undefined") {
      hidden = "msHidden";
      visibilityChange = "msvisibilitychange";
    } else if (typeof globalThis.document.webkitHidden !== "undefined") {
      hidden = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
    }
    this.hidden = hidden;
    this.visibilityChange = visibilityChange;
  }
  _addVisibilityChangeListener() {
    if (typeof globalThis.document.addEventListener === "undefined" || typeof document[this.hidden] === "undefined") {
      log2("Checking page visibility requires a browser that supports the Page Visibility API.");
    } else {
      globalThis.document.addEventListener(this.visibilityChange, this._handleVisibilityChange.bind(this), false);
    }
  }
  isVisible() {
    if (this.hidden === void 0 || document[this.hidden] === void 0) {
      return void 0;
    }
    return document[this.hidden] == null;
  }
  _handleVisibilityChange() {
    const visible = globalThis.document[this.hidden] === false;
    log2(visible ? "Page Visible" : "Page Hidden");
    this.dispatchEvent(new CustomEvent("visibilityChange", {
      detail: visible
    }));
  }
};

// node_modules/libp2p/dist/src/connection-manager/latency-monitor.js
var log3 = logger("libp2p:connection-manager:latency-monitor");
var LatencyMonitor = class extends EventEmitter {
  constructor(init = {}) {
    super();
    const { latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = init;
    this.latencyCheckIntervalMs = latencyCheckIntervalMs ?? 500;
    this.latencyRandomPercentage = latencyRandomPercentage ?? 10;
    this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100) * this.latencyCheckIntervalMs;
    this.latencyCheckSubtract = this.latencyCheckMultiply / 2;
    this.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs ?? 5 * 1e3;
    log3("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", this.latencyCheckIntervalMs, this.dataEmitIntervalMs);
    if (this.dataEmitIntervalMs != null) {
      log3("Expecting ~%s events per summary", this.latencyCheckIntervalMs / this.dataEmitIntervalMs);
    } else {
      log3("Not emitting summaries");
    }
    this.asyncTestFn = asyncTestFn;
    if (globalThis.process?.hrtime != null) {
      log3("Using process.hrtime for timing");
      this.now = globalThis.process.hrtime;
      this.getDeltaMS = (startTime) => {
        const hrtime = this.now(startTime);
        return hrtime[0] * 1e3 + hrtime[1] / 1e6;
      };
    } else if (typeof window !== "undefined" && window.performance?.now != null) {
      log3("Using performance.now for timing");
      this.now = window.performance.now.bind(window.performance);
      this.getDeltaMS = (startTime) => Math.round(this.now() - startTime);
    } else {
      log3("Using Date.now for timing");
      this.now = Date.now;
      this.getDeltaMS = (startTime) => this.now() - startTime;
    }
    this.latencyData = this.initLatencyData();
  }
  start() {
    if (isBrowser2()) {
      this.visibilityChangeEmitter = new VisibilityChangeEmitter();
      this.visibilityChangeEmitter.addEventListener("visibilityChange", (evt) => {
        const { detail: pageInFocus } = evt;
        if (pageInFocus) {
          this._startTimers();
        } else {
          this._emitSummary();
          this._stopTimers();
        }
      });
    }
    if (this.visibilityChangeEmitter?.isVisible() === true) {
      this._startTimers();
    }
  }
  stop() {
    this._stopTimers();
  }
  _startTimers() {
    if (this.checkLatencyID != null) {
      return;
    }
    this.checkLatency();
    if (this.dataEmitIntervalMs != null) {
      this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
      if (typeof this.emitIntervalID.unref === "function") {
        this.emitIntervalID.unref();
      }
    }
  }
  _stopTimers() {
    if (this.checkLatencyID != null) {
      clearTimeout(this.checkLatencyID);
      this.checkLatencyID = void 0;
    }
    if (this.emitIntervalID != null) {
      clearInterval(this.emitIntervalID);
      this.emitIntervalID = void 0;
    }
  }
  _emitSummary() {
    const summary = this.getSummary();
    if (summary.events > 0) {
      this.dispatchEvent(new CustomEvent("data", {
        detail: summary
      }));
    }
  }
  getSummary() {
    const latency = {
      events: this.latencyData.events,
      minMs: this.latencyData.minMs,
      maxMs: this.latencyData.maxMs,
      avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY,
      lengthMs: this.getDeltaMS(this.latencyData.startTime)
    };
    this.latencyData = this.initLatencyData();
    log3.trace("Summary: %O", latency);
    return latency;
  }
  checkLatency() {
    const randomness = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract;
    const localData = {
      deltaOffset: Math.ceil(this.latencyCheckIntervalMs + randomness),
      startTime: this.now()
    };
    const cb = () => {
      if (this.checkLatencyID == null) {
        return;
      }
      const deltaMS = this.getDeltaMS(localData.startTime) - localData.deltaOffset;
      this.checkLatency();
      this.latencyData.events++;
      this.latencyData.minMs = Math.min(this.latencyData.minMs, deltaMS);
      this.latencyData.maxMs = Math.max(this.latencyData.maxMs, deltaMS);
      this.latencyData.totalMs += deltaMS;
      log3.trace("MS: %s Data: %O", deltaMS, this.latencyData);
    };
    log3.trace("localData: %O", localData);
    this.checkLatencyID = setTimeout(() => {
      if (this.asyncTestFn != null) {
        localData.deltaOffset = 0;
        localData.startTime = this.now();
        this.asyncTestFn(cb);
      } else {
        localData.deltaOffset -= 1;
        cb();
      }
    }, localData.deltaOffset);
    if (typeof this.checkLatencyID.unref === "function") {
      this.checkLatencyID.unref();
    }
  }
  initLatencyData() {
    return {
      startTime: this.now(),
      minMs: Number.POSITIVE_INFINITY,
      maxMs: Number.NEGATIVE_INFINITY,
      events: 0,
      totalMs: 0
    };
  }
};
function isBrowser2() {
  return typeof globalThis.window !== "undefined";
}

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_retimer = __toESM(require_retimer(), 1);
var import_events6 = __toESM(require_events(), 1);

// node_modules/@libp2p/interface-connection/dist/src/status.js
var OPEN = "OPEN";
var CLOSING = "CLOSING";
var CLOSED = "CLOSED";

// node_modules/@libp2p/peer-collections/dist/src/util.js
function mapIterable(iter, map3) {
  const iterator = {
    [Symbol.iterator]: () => {
      return iterator;
    },
    next: () => {
      const next = iter.next();
      const val = next.value;
      if (next.done === true || val == null) {
        const result = {
          done: true,
          value: void 0
        };
        return result;
      }
      return {
        done: false,
        value: map3(val)
      };
    }
  };
  return iterator;
}

// node_modules/@libp2p/peer-collections/dist/src/map.js
var PeerMap = class {
  constructor(map3) {
    this.map = /* @__PURE__ */ new Map();
    if (map3 != null) {
      for (const [key, value] of map3.entries()) {
        this.map.set(key.toString(), value);
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  clear() {
    this.map.clear();
  }
  delete(peer) {
    this.map.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.map.entries(), (val) => {
      return [peerIdFromString(val[0]), val[1]];
    });
  }
  forEach(fn) {
    this.map.forEach((value, key) => {
      fn(value, peerIdFromString(key), this);
    });
  }
  get(peer) {
    return this.map.get(peer.toString());
  }
  has(peer) {
    return this.map.has(peer.toString());
  }
  set(peer, value) {
    this.map.set(peer.toString(), value);
  }
  keys() {
    return mapIterable(this.map.keys(), (val) => {
      return peerIdFromString(val);
    });
  }
  values() {
    return this.map.values();
  }
  get size() {
    return this.map.size;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/set.js
var PeerSet = class {
  constructor(set) {
    this.set = /* @__PURE__ */ new Set();
    if (set != null) {
      for (const key of set) {
        this.set.add(key.toString());
      }
    }
  }
  get size() {
    return this.set.size;
  }
  [Symbol.iterator]() {
    return this.values();
  }
  add(peer) {
    this.set.add(peer.toString());
  }
  clear() {
    this.set.clear();
  }
  delete(peer) {
    this.set.delete(peer.toString());
  }
  entries() {
    return mapIterable(this.set.entries(), (val) => {
      const peerId = peerIdFromString(val[0]);
      return [peerId, peerId];
    });
  }
  forEach(predicate) {
    this.set.forEach((str) => {
      const id = peerIdFromString(str);
      predicate(id, id, this);
    });
  }
  has(peer) {
    return this.set.has(peer.toString());
  }
  values() {
    return mapIterable(this.set.values(), (val) => {
      return peerIdFromString(val);
    });
  }
  intersection(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      if (this.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  difference(other) {
    const output = new PeerSet();
    for (const peerId of this) {
      if (!other.has(peerId)) {
        output.add(peerId);
      }
    }
    return output;
  }
  union(other) {
    const output = new PeerSet();
    for (const peerId of other) {
      output.add(peerId);
    }
    for (const peerId of this) {
      output.add(peerId);
    }
    return output;
  }
};

// node_modules/@libp2p/peer-collections/dist/src/list.js
var PeerList = class {
  constructor(list) {
    this.list = [];
    if (list != null) {
      for (const value of list) {
        this.list.push(value.toString());
      }
    }
  }
  [Symbol.iterator]() {
    return mapIterable(this.list.entries(), (val) => {
      return peerIdFromString(val[1]);
    });
  }
  concat(list) {
    const output = new PeerList(this);
    for (const value of list) {
      output.push(value);
    }
    return output;
  }
  entries() {
    return mapIterable(this.list.entries(), (val) => {
      return [val[0], peerIdFromString(val[1])];
    });
  }
  every(predicate) {
    return this.list.every((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  filter(predicate) {
    const output = new PeerList();
    this.list.forEach((str, index) => {
      const peerId = peerIdFromString(str);
      if (predicate(peerId, index, this)) {
        output.push(peerId);
      }
    });
    return output;
  }
  find(predicate) {
    const str = this.list.find((str2, index) => {
      return predicate(peerIdFromString(str2), index, this);
    });
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  findIndex(predicate) {
    return this.list.findIndex((str, index) => {
      return predicate(peerIdFromString(str), index, this);
    });
  }
  forEach(predicate) {
    this.list.forEach((str, index) => {
      predicate(peerIdFromString(str), index, this);
    });
  }
  includes(peerId) {
    return this.list.includes(peerId.toString());
  }
  indexOf(peerId) {
    return this.list.indexOf(peerId.toString());
  }
  pop() {
    const str = this.list.pop();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  push(...peerIds) {
    for (const peerId of peerIds) {
      this.list.push(peerId.toString());
    }
  }
  shift() {
    const str = this.list.shift();
    if (str == null) {
      return void 0;
    }
    return peerIdFromString(str);
  }
  unshift(...peerIds) {
    let len = this.list.length;
    for (let i = peerIds.length - 1; i > -1; i--) {
      len = this.list.unshift(peerIds[i].toString());
    }
    return len;
  }
  get length() {
    return this.list.length;
  }
};

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_timeout_abort_controller2 = __toESM(require_timeout_abort_controller(), 1);

// node_modules/@libp2p/interface-peer-store/dist/src/tags.js
var KEEP_ALIVE = "keep-alive";

// node_modules/libp2p/dist/src/connection-manager/index.js
var import_rate_limiter_flexible = __toESM(require_rate_limiter_flexible(), 1);
var log4 = logger("libp2p:connection-manager");
var defaultOptions = {
  maxConnections: Infinity,
  minConnections: 0,
  maxData: Infinity,
  maxSentData: Infinity,
  maxReceivedData: Infinity,
  maxEventLoopDelay: Infinity,
  pollInterval: 2e3,
  autoDialInterval: 1e4,
  movingAverageInterval: 6e4,
  inboundConnectionThreshold: 5,
  maxIncomingPendingConnections: 10
};
var METRICS_SYSTEM = "libp2p";
var METRICS_COMPONENT = "connection-manager";
var STARTUP_RECONNECT_TIMEOUT = 6e4;
var DefaultConnectionManager = class extends EventEmitter {
  constructor(components, init) {
    super();
    this.opts = merge_options_default.call({ ignoreUndefined: true }, defaultOptions, init);
    if (this.opts.maxConnections < this.opts.minConnections) {
      throw (0, import_err_code6.default)(new Error("Connection Manager maxConnections must be greater than minConnections"), codes.ERR_INVALID_PARAMETERS);
    }
    log4("options: %o", this.opts);
    this.components = components;
    this.connections = /* @__PURE__ */ new Map();
    this.started = false;
    this._checkMetrics = this._checkMetrics.bind(this);
    this.latencyMonitor = new LatencyMonitor({
      latencyCheckIntervalMs: init.pollInterval,
      dataEmitIntervalMs: init.pollInterval
    });
    try {
      (0, import_events6.setMaxListeners)?.(Infinity, this);
    } catch {
    }
    this.onConnect = this.onConnect.bind(this);
    this.onDisconnect = this.onDisconnect.bind(this);
    this.startupReconnectTimeout = init.startupReconnectTimeout ?? STARTUP_RECONNECT_TIMEOUT;
    this.dialTimeout = init.dialTimeout ?? 3e4;
    this.allow = (init.allow ?? []).map((ma) => multiaddr(ma));
    this.deny = (init.deny ?? []).map((ma) => multiaddr(ma));
    this.inboundConnectionRateLimiter = new import_rate_limiter_flexible.RateLimiterMemory({
      points: this.opts.inboundConnectionThreshold,
      duration: 1
    });
    this.incomingPendingConnections = 0;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.components.metrics != null) {
      this.timer = this.timer ?? (0, import_retimer.default)(this._checkMetrics, this.opts.pollInterval);
    }
    this.components.metrics?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "connections",
      label: "direction",
      value: () => {
        const metric = {
          inbound: 0,
          outbound: 0
        };
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            if (conn.stat.direction === "inbound") {
              metric.inbound++;
            } else {
              metric.outbound++;
            }
          }
        }
        return metric;
      }
    });
    this.components.metrics?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "protocol-streams-total",
      label: "protocol",
      value: () => {
        const metric = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              metric[key] = (metric[key] ?? 0) + 1;
            }
          }
        }
        return metric;
      }
    });
    this.components.metrics?.updateComponentMetric({
      system: METRICS_SYSTEM,
      component: METRICS_COMPONENT,
      metric: "protocol-streams-per-connection-90th-percentile",
      label: "protocol",
      value: () => {
        const allStreams = {};
        for (const conns of this.connections.values()) {
          for (const conn of conns) {
            const streams = {};
            for (const stream of conn.streams) {
              const key = `${stream.stat.direction} ${stream.stat.protocol ?? "unnegotiated"}`;
              streams[key] = (streams[key] ?? 0) + 1;
            }
            for (const [protocol, count] of Object.entries(streams)) {
              allStreams[protocol] = allStreams[protocol] ?? [];
              allStreams[protocol].push(count);
            }
          }
        }
        const metric = {};
        for (let [protocol, counts] of Object.entries(allStreams)) {
          counts = counts.sort((a, b) => a - b);
          const index = Math.floor(counts.length * 0.9);
          metric[protocol] = counts[index];
        }
        return metric;
      }
    });
    this.latencyMonitor.start();
    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
    this.latencyMonitor.addEventListener("data", this._onLatencyMeasure);
    this.started = true;
    log4("started");
  }
  async afterStart() {
    this.components.upgrader.addEventListener("connection", this.onConnect);
    this.components.upgrader.addEventListener("connectionEnd", this.onDisconnect);
    void Promise.resolve().then(async () => {
      const keepAlivePeers = [];
      for (const peer of await this.components.peerStore.all()) {
        const tags = await this.components.peerStore.getTags(peer.id);
        const hasKeepAlive = tags.filter((tag) => tag.name === KEEP_ALIVE).length > 0;
        if (hasKeepAlive) {
          keepAlivePeers.push(peer.id);
        }
      }
      this.connectOnStartupController?.clear();
      this.connectOnStartupController = new import_timeout_abort_controller2.TimeoutController(this.startupReconnectTimeout);
      try {
        (0, import_events6.setMaxListeners)?.(Infinity, this.connectOnStartupController.signal);
      } catch {
      }
      await Promise.all(keepAlivePeers.map(async (peer) => {
        await this.openConnection(peer, {
          signal: this.connectOnStartupController?.signal
        }).catch((err) => {
          log4.error(err);
        });
      }));
    }).catch((err) => {
      log4.error(err);
    }).finally(() => {
      this.connectOnStartupController?.clear();
    });
  }
  async beforeStop() {
    this.connectOnStartupController?.abort();
    this.components.upgrader.removeEventListener("connection", this.onConnect);
    this.components.upgrader.removeEventListener("connectionEnd", this.onDisconnect);
  }
  async stop() {
    this.timer?.clear();
    this.latencyMonitor.removeEventListener("data", this._onLatencyMeasure);
    this.latencyMonitor.stop();
    this.started = false;
    await this._close();
    log4("stopped");
  }
  async _close() {
    const tasks = [];
    for (const connectionList of this.connections.values()) {
      for (const connection of connectionList) {
        tasks.push((async () => {
          try {
            await connection.close();
          } catch (err) {
            log4.error(err);
          }
        })());
      }
    }
    log4("closing %d connections", tasks.length);
    await Promise.all(tasks);
    this.connections.clear();
  }
  async _checkMetrics() {
    const metrics = this.components.metrics;
    if (metrics != null) {
      try {
        const movingAverages = metrics.getGlobal().getMovingAverages();
        const received = movingAverages.dataReceived[this.opts.movingAverageInterval].movingAverage;
        await this._checkMaxLimit("maxReceivedData", received);
        const sent = movingAverages.dataSent[this.opts.movingAverageInterval].movingAverage;
        await this._checkMaxLimit("maxSentData", sent);
        const total = received + sent;
        await this._checkMaxLimit("maxData", total);
        log4.trace("metrics update", total);
      } finally {
        this.timer = (0, import_retimer.default)(this._checkMetrics, this.opts.pollInterval);
      }
    }
  }
  onConnect(evt) {
    void this._onConnect(evt).catch((err) => {
      log4.error(err);
    });
  }
  async _onConnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      await connection.close();
      return;
    }
    const peerId = connection.remotePeer;
    const peerIdStr = peerId.toString();
    const storedConns = this.connections.get(peerIdStr);
    if (storedConns != null) {
      storedConns.push(connection);
    } else {
      this.connections.set(peerIdStr, [connection]);
    }
    if (peerId.publicKey != null) {
      await this.components.peerStore.keyBook.set(peerId, peerId.publicKey);
    }
    const numConnections = this.getConnections().length;
    const toPrune = numConnections - this.opts.maxConnections;
    await this._checkMaxLimit("maxConnections", numConnections, toPrune);
    this.dispatchEvent(new CustomEvent("peer:connect", { detail: connection }));
  }
  onDisconnect(evt) {
    const { detail: connection } = evt;
    if (!this.started) {
      return;
    }
    const peerId = connection.remotePeer.toString();
    let storedConn = this.connections.get(peerId);
    if (storedConn != null && storedConn.length > 1) {
      storedConn = storedConn.filter((conn) => conn.id !== connection.id);
      this.connections.set(peerId, storedConn);
    } else if (storedConn != null) {
      this.connections.delete(peerId);
      this.dispatchEvent(new CustomEvent("peer:disconnect", { detail: connection }));
      this.components.metrics?.onPeerDisconnected(connection.remotePeer);
    }
  }
  getConnections(peerId) {
    if (peerId != null) {
      return this.connections.get(peerId.toString()) ?? [];
    }
    let conns = [];
    for (const c of this.connections.values()) {
      conns = conns.concat(c);
    }
    return conns;
  }
  async openConnection(peerId, options = {}) {
    log4("dial to %p", peerId);
    const existingConnections = this.getConnections(peerId);
    if (existingConnections.length > 0) {
      log4("had an existing connection to %p", peerId);
      return existingConnections[0];
    }
    let timeoutController;
    if (options?.signal == null) {
      timeoutController = new import_timeout_abort_controller2.TimeoutController(this.dialTimeout);
      options.signal = timeoutController.signal;
      try {
        (0, import_events6.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      const connection = await this.components.dialer.dial(peerId, options);
      let peerConnections = this.connections.get(peerId.toString());
      if (peerConnections == null) {
        peerConnections = [];
        this.connections.set(peerId.toString(), peerConnections);
      }
      let trackedConnection = false;
      for (const conn of peerConnections) {
        if (conn.id === connection.id) {
          trackedConnection = true;
        }
      }
      if (!trackedConnection) {
        peerConnections.push(connection);
      }
      return connection;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
    }
  }
  async closeConnections(peerId) {
    const connections = this.connections.get(peerId.toString()) ?? [];
    await Promise.all(connections.map(async (connection) => {
      return await connection.close();
    }));
  }
  getAll(peerId) {
    if (!isPeerId(peerId)) {
      throw (0, import_err_code6.default)(new Error("peerId must be an instance of peer-id"), codes.ERR_INVALID_PARAMETERS);
    }
    const id = peerId.toString();
    const connections = this.connections.get(id);
    if (connections != null) {
      return connections.filter((connection) => connection.stat.status === OPEN);
    }
    return [];
  }
  _onLatencyMeasure(evt) {
    const { detail: summary } = evt;
    this._checkMaxLimit("maxEventLoopDelay", summary.avgMs, 1).catch((err) => {
      log4.error(err);
    });
  }
  async _checkMaxLimit(name2, value, toPrune = 1) {
    const limit = this.opts[name2];
    log4.trace("checking limit of %s. current value: %d of %d", name2, value, limit);
    if (value > limit) {
      log4("%s: limit exceeded: %p, %d/%d, pruning %d connection(s)", this.components.peerId, name2, value, limit, toPrune);
      await this._pruneConnections(toPrune);
    }
  }
  async _pruneConnections(toPrune) {
    const connections = this.getConnections();
    const peerValues = new PeerMap();
    for (const connection of connections) {
      const remotePeer = connection.remotePeer;
      if (peerValues.has(remotePeer)) {
        continue;
      }
      const tags = await this.components.peerStore.getTags(remotePeer);
      peerValues.set(remotePeer, tags.reduce((acc, curr) => {
        return acc + curr.value;
      }, 0));
    }
    const sortedConnections = connections.sort((a, b) => {
      const peerAValue = peerValues.get(a.remotePeer) ?? 0;
      const peerBValue = peerValues.get(b.remotePeer) ?? 0;
      if (peerAValue > peerBValue) {
        return 1;
      }
      if (peerAValue < peerBValue) {
        return -1;
      }
      return 0;
    });
    const toClose = [];
    for (const connection of sortedConnections) {
      log4("too many connections open - closing a connection to %p", connection.remotePeer);
      toClose.push(connection);
      if (toClose.length === toPrune) {
        break;
      }
    }
    await Promise.all(toClose.map(async (connection) => {
      try {
        await connection.close();
      } catch (err) {
        log4.error(err);
      }
      this.onDisconnect(new CustomEvent("connectionEnd", {
        detail: connection
      }));
    }));
  }
  async acceptIncomingConnection(maConn) {
    const denyConnection = this.deny.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (denyConnection) {
      log4("connection from %s refused - connection remote address was in deny list", maConn.remoteAddr);
      return false;
    }
    const allowConnection = this.allow.some((ma) => {
      return maConn.remoteAddr.toString().startsWith(ma.toString());
    });
    if (allowConnection) {
      this.incomingPendingConnections++;
      return true;
    }
    if (this.incomingPendingConnections === this.opts.maxIncomingPendingConnections) {
      log4("connection from %s refused - incomingPendingConnections exceeded by peer %s", maConn.remoteAddr);
      return false;
    }
    if (maConn.remoteAddr.isThinWaistAddress()) {
      const host = maConn.remoteAddr.nodeAddress().address;
      try {
        await this.inboundConnectionRateLimiter.consume(host, 1);
      } catch {
        log4("connection from %s refused - inboundConnectionThreshold exceeded by host %s", host, maConn.remoteAddr);
        return false;
      }
    }
    if (this.getConnections().length < this.opts.maxConnections) {
      this.incomingPendingConnections++;
      return true;
    }
    log4("connection from %s refused - maxConnections exceeded", maConn.remoteAddr);
    return false;
  }
  afterUpgradeInbound() {
    this.incomingPendingConnections--;
  }
};

// node_modules/libp2p/dist/src/connection-manager/auto-dialler.js
var import_retimer2 = __toESM(require_retimer(), 1);

// node_modules/it-all/dist/src/index.js
async function all2(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}

// node_modules/it-sort/dist/src/index.js
async function* sort(source, sorter) {
  const arr = await all2(source);
  yield* arr.sort(sorter);
}

// node_modules/libp2p/dist/src/connection-manager/auto-dialler.js
var log5 = logger("libp2p:connection-manager:auto-dialler");
var defaultOptions2 = {
  enabled: true,
  minConnections: 0,
  autoDialInterval: 1e4
};
var AutoDialler = class {
  constructor(components, init) {
    this.components = components;
    this.options = merge_options_default.call({ ignoreUndefined: true }, defaultOptions2, init);
    this.running = false;
    this._autoDial = this._autoDial.bind(this);
    log5("options: %j", this.options);
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (!this.options.enabled) {
      log5("not enabled");
      return;
    }
    this.running = true;
    void this._autoDial().catch((err) => {
      log5.error("could start autodial", err);
    });
    log5("started");
  }
  async stop() {
    if (!this.options.enabled) {
      log5("not enabled");
      return;
    }
    this.running = false;
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    log5("stopped");
  }
  async _autoDial() {
    if (this.autoDialTimeout != null) {
      this.autoDialTimeout.clear();
    }
    const minConnections = this.options.minConnections;
    if (this.components.connectionManager.getConnections().length >= minConnections) {
      this.autoDialTimeout = (0, import_retimer2.default)(this._autoDial, this.options.autoDialInterval);
      return;
    }
    const allPeers = await this.components.peerStore.all();
    const peers = await pipe(
      allPeers.sort(() => Math.random() > 0.5 ? 1 : -1),
      (source) => filter2(source, (peer) => !peer.id.equals(this.components.peerId)),
      (source) => sort(source, (a, b) => {
        if (b.protocols.length > a.protocols.length) {
          return 1;
        } else if (b.id.publicKey != null && a.id.publicKey == null) {
          return 1;
        }
        return -1;
      }),
      async (source) => await all2(source)
    );
    for (let i = 0; this.running && i < peers.length && this.components.connectionManager.getConnections().length < minConnections; i++) {
      if (!this.running) {
        return;
      }
      const peer = peers[i];
      if (this.components.connectionManager.getConnections(peer.id).length === 0) {
        log5("connecting to a peerStore stored peer %p", peer.id);
        try {
          await this.components.connectionManager.openConnection(peer.id);
        } catch (err) {
          log5.error("could not connect to peerStore stored peer", err);
        }
      }
    }
    if (!this.running) {
      return;
    }
    this.autoDialTimeout = (0, import_retimer2.default)(this._autoDial, this.options.autoDialInterval);
  }
};

// node_modules/libp2p/dist/src/circuit/transport.js
var import_err_code8 = __toESM(require_err_code(), 1);

// node_modules/libp2p/node_modules/protons-runtime/dist/src/utils.js
var import_reader = __toESM(require_reader(), 1);
var import_reader_buffer = __toESM(require_reader_buffer(), 1);
var import_writer = __toESM(require_writer(), 1);
var import_writer_buffer = __toESM(require_writer_buffer(), 1);
var import_minimal = __toESM(require_minimal(), 1);
function configure() {
  import_minimal.default._configure();
  import_reader.default._configure(import_reader_buffer.default);
  import_writer.default._configure(import_writer_buffer.default);
}
configure();
var methods = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader(buf) {
  return patchReader(new import_reader.default(buf));
}
function patchWriter(obj) {
  for (const method of methods) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer() {
  return patchWriter(import_writer.default.create());
}

// node_modules/libp2p/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage(buf, codec) {
  const r = reader(buf instanceof Uint8Array ? buf : buf.subarray());
  return codec.decode(r);
}

// node_modules/libp2p/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage(message5, codec) {
  const w = writer();
  codec.encode(message5, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/libp2p/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES;
(function(CODEC_TYPES5) {
  CODEC_TYPES5[CODEC_TYPES5["VARINT"] = 0] = "VARINT";
  CODEC_TYPES5[CODEC_TYPES5["BIT64"] = 1] = "BIT64";
  CODEC_TYPES5[CODEC_TYPES5["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES5[CODEC_TYPES5["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES5[CODEC_TYPES5["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES5[CODEC_TYPES5["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES || (CODEC_TYPES = {}));
function createCodec2(name2, type, encode3, decode2) {
  return {
    name: name2,
    type,
    encode: encode3,
    decode: decode2
  };
}

// node_modules/libp2p/node_modules/protons-runtime/dist/src/codecs/enum.js
function enumeration(v) {
  function findValue(val) {
    if (v[val.toString()] == null) {
      throw new Error("Invalid enum value");
    }
    return v[val];
  }
  const encode3 = function enumEncode(val, writer5) {
    const enumValue = findValue(val);
    writer5.int32(enumValue);
  };
  const decode2 = function enumDecode(reader6) {
    const val = reader6.int32();
    return findValue(val);
  };
  return createCodec2("enum", CODEC_TYPES.VARINT, encode3, decode2);
}

// node_modules/libp2p/node_modules/protons-runtime/dist/src/codecs/message.js
function message(encode3, decode2) {
  return createCodec2("message", CODEC_TYPES.LENGTH_DELIMITED, encode3, decode2);
}

// node_modules/libp2p/dist/src/circuit/pb/index.js
var CircuitRelay;
(function(CircuitRelay2) {
  let Status;
  (function(Status2) {
    Status2["SUCCESS"] = "SUCCESS";
    Status2["HOP_SRC_ADDR_TOO_LONG"] = "HOP_SRC_ADDR_TOO_LONG";
    Status2["HOP_DST_ADDR_TOO_LONG"] = "HOP_DST_ADDR_TOO_LONG";
    Status2["HOP_SRC_MULTIADDR_INVALID"] = "HOP_SRC_MULTIADDR_INVALID";
    Status2["HOP_DST_MULTIADDR_INVALID"] = "HOP_DST_MULTIADDR_INVALID";
    Status2["HOP_NO_CONN_TO_DST"] = "HOP_NO_CONN_TO_DST";
    Status2["HOP_CANT_DIAL_DST"] = "HOP_CANT_DIAL_DST";
    Status2["HOP_CANT_OPEN_DST_STREAM"] = "HOP_CANT_OPEN_DST_STREAM";
    Status2["HOP_CANT_SPEAK_RELAY"] = "HOP_CANT_SPEAK_RELAY";
    Status2["HOP_CANT_RELAY_TO_SELF"] = "HOP_CANT_RELAY_TO_SELF";
    Status2["STOP_SRC_ADDR_TOO_LONG"] = "STOP_SRC_ADDR_TOO_LONG";
    Status2["STOP_DST_ADDR_TOO_LONG"] = "STOP_DST_ADDR_TOO_LONG";
    Status2["STOP_SRC_MULTIADDR_INVALID"] = "STOP_SRC_MULTIADDR_INVALID";
    Status2["STOP_DST_MULTIADDR_INVALID"] = "STOP_DST_MULTIADDR_INVALID";
    Status2["STOP_RELAY_REFUSED"] = "STOP_RELAY_REFUSED";
    Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  })(Status = CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  let __StatusValues;
  (function(__StatusValues2) {
    __StatusValues2[__StatusValues2["SUCCESS"] = 100] = "SUCCESS";
    __StatusValues2[__StatusValues2["HOP_SRC_ADDR_TOO_LONG"] = 220] = "HOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_DST_ADDR_TOO_LONG"] = 221] = "HOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["HOP_SRC_MULTIADDR_INVALID"] = 250] = "HOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_DST_MULTIADDR_INVALID"] = 251] = "HOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["HOP_NO_CONN_TO_DST"] = 260] = "HOP_NO_CONN_TO_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_DIAL_DST"] = 261] = "HOP_CANT_DIAL_DST";
    __StatusValues2[__StatusValues2["HOP_CANT_OPEN_DST_STREAM"] = 262] = "HOP_CANT_OPEN_DST_STREAM";
    __StatusValues2[__StatusValues2["HOP_CANT_SPEAK_RELAY"] = 270] = "HOP_CANT_SPEAK_RELAY";
    __StatusValues2[__StatusValues2["HOP_CANT_RELAY_TO_SELF"] = 280] = "HOP_CANT_RELAY_TO_SELF";
    __StatusValues2[__StatusValues2["STOP_SRC_ADDR_TOO_LONG"] = 320] = "STOP_SRC_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_DST_ADDR_TOO_LONG"] = 321] = "STOP_DST_ADDR_TOO_LONG";
    __StatusValues2[__StatusValues2["STOP_SRC_MULTIADDR_INVALID"] = 350] = "STOP_SRC_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_DST_MULTIADDR_INVALID"] = 351] = "STOP_DST_MULTIADDR_INVALID";
    __StatusValues2[__StatusValues2["STOP_RELAY_REFUSED"] = 390] = "STOP_RELAY_REFUSED";
    __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  })(__StatusValues || (__StatusValues = {}));
  (function(Status2) {
    Status2.codec = () => {
      return enumeration(__StatusValues);
    };
  })(Status = CircuitRelay2.Status || (CircuitRelay2.Status = {}));
  let Type;
  (function(Type2) {
    Type2["HOP"] = "HOP";
    Type2["STOP"] = "STOP";
    Type2["STATUS"] = "STATUS";
    Type2["CAN_HOP"] = "CAN_HOP";
  })(Type = CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["HOP"] = 1] = "HOP";
    __TypeValues2[__TypeValues2["STOP"] = 2] = "STOP";
    __TypeValues2[__TypeValues2["STATUS"] = 3] = "STATUS";
    __TypeValues2[__TypeValues2["CAN_HOP"] = 4] = "CAN_HOP";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = CircuitRelay2.Type || (CircuitRelay2.Type = {}));
  let Peer2;
  (function(Peer3) {
    let _codec2;
    Peer3.codec = () => {
      if (_codec2 == null) {
        _codec2 = message((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (opts.writeDefaults === true || obj.id != null && obj.id.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.id);
          }
          if (obj.addrs != null) {
            for (const value of obj.addrs) {
              w.uint32(18);
              w.bytes(value);
            }
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader6, length) => {
          const obj = {
            id: new Uint8Array(0),
            addrs: []
          };
          const end = length == null ? reader6.len : reader6.pos + length;
          while (reader6.pos < end) {
            const tag = reader6.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.id = reader6.bytes();
                break;
              case 2:
                obj.addrs.push(reader6.bytes());
                break;
              default:
                reader6.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    Peer3.encode = (obj) => {
      return encodeMessage(obj, Peer3.codec());
    };
    Peer3.decode = (buf) => {
      return decodeMessage(buf, Peer3.codec());
    };
  })(Peer2 = CircuitRelay2.Peer || (CircuitRelay2.Peer = {}));
  let _codec;
  CircuitRelay2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          CircuitRelay2.Type.codec().encode(obj.type, w);
        }
        if (obj.srcPeer != null) {
          w.uint32(18);
          CircuitRelay2.Peer.codec().encode(obj.srcPeer, w, {
            writeDefaults: false
          });
        }
        if (obj.dstPeer != null) {
          w.uint32(26);
          CircuitRelay2.Peer.codec().encode(obj.dstPeer, w, {
            writeDefaults: false
          });
        }
        if (obj.code != null) {
          w.uint32(32);
          CircuitRelay2.Status.codec().encode(obj.code, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {};
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = CircuitRelay2.Type.codec().decode(reader6);
              break;
            case 2:
              obj.srcPeer = CircuitRelay2.Peer.codec().decode(reader6, reader6.uint32());
              break;
            case 3:
              obj.dstPeer = CircuitRelay2.Peer.codec().decode(reader6, reader6.uint32());
              break;
            case 4:
              obj.code = CircuitRelay2.Status.codec().decode(reader6);
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  CircuitRelay2.encode = (obj) => {
    return encodeMessage(obj, CircuitRelay2.codec());
  };
  CircuitRelay2.decode = (buf) => {
    return decodeMessage(buf, CircuitRelay2.codec());
  };
})(CircuitRelay || (CircuitRelay = {}));

// node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
var log6 = logger("libp2p:stream:converter");
function streamToMaConnection(props, options = {}) {
  const { stream, remoteAddr } = props;
  const { sink, source } = stream;
  const mapSource = async function* () {
    for await (const list of source) {
      yield* list;
    }
  }();
  const maConn = {
    async sink(source2) {
      if (options.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await sink(source2);
        await close();
      } catch (err) {
        if (err.type !== "aborted") {
          log6(err);
        }
      }
    },
    source: options.signal != null ? abortableSource(mapSource, options.signal) : mapSource,
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    async close() {
      await sink(async function* () {
        yield new Uint8Array(0);
      }());
      await close();
    }
  };
  async function close() {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
    return await Promise.resolve();
  }
  return maConn;
}

// node_modules/libp2p/dist/src/circuit/multicodec.js
var RELAY_CODEC = "/libp2p/circuit/relay/0.1.0";

// node_modules/libp2p/dist/src/circuit/listener.js
function createListener(options) {
  const listeningAddrs = /* @__PURE__ */ new Map();
  async function listen(addr) {
    const addrString = addr.toString().split("/p2p-circuit").find((a) => a !== "");
    const ma = multiaddr(addrString);
    const relayPeerStr = ma.getPeerId();
    if (relayPeerStr == null) {
      throw new Error("Could not determine relay peer from multiaddr");
    }
    const relayPeerId = peerIdFromString(relayPeerStr);
    await options.peerStore.addressBook.add(relayPeerId, [ma]);
    const relayConn = await options.connectionManager.openConnection(relayPeerId);
    const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
    listeningAddrs.set(relayConn.remotePeer.toString(), relayedAddr);
    listener.dispatchEvent(new CustomEvent("listening"));
  }
  function getAddrs() {
    const addrs = [];
    for (const addr of listeningAddrs.values()) {
      addrs.push(addr);
    }
    return addrs;
  }
  const listener = Object.assign(new EventEmitter(), {
    close: async () => await Promise.resolve(),
    listen,
    getAddrs
  });
  options.connectionManager.addEventListener("peer:disconnect", (evt) => {
    const { detail: connection } = evt;
    const deleted = listeningAddrs.delete(connection.remotePeer.toString());
    if (deleted) {
      listener.dispatchEvent(new CustomEvent("close"));
    }
  });
  return listener;
}

// node_modules/libp2p/dist/src/circuit/circuit/hop.js
var import_err_code7 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/circuit/circuit/utils.js
function writeResponse(streamHandler, status) {
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: status
  });
}
function validateAddrs(msg, streamHandler) {
  try {
    if (msg.dstPeer?.addrs != null) {
      msg.dstPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
    throw err;
  }
  try {
    if (msg.srcPeer?.addrs != null) {
      msg.srcPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    }
  } catch (err) {
    writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
    throw err;
  }
}

// node_modules/libp2p/dist/src/circuit/circuit/stream-handler.js
var log7 = logger("libp2p:circuit:stream-handler");
var StreamHandler = class {
  constructor(options) {
    const { stream, maxLength = 4096 } = options;
    this.stream = stream;
    this.shake = handshake(this.stream);
    this.decoder = decode.fromReader(this.shake.reader, { maxDataLength: maxLength });
  }
  async read() {
    const msg = await this.decoder.next();
    if (msg.value != null) {
      const value = CircuitRelay.decode(msg.value);
      log7("read message type", value.type);
      return value;
    }
    log7("read received no value, closing stream");
    this.close();
  }
  write(msg) {
    log7("write message type %s", msg.type);
    this.shake.write(encode.single(CircuitRelay.encode(msg)));
  }
  rest() {
    this.shake.rest();
    return this.shake.stream;
  }
  end(msg) {
    this.write(msg);
    this.close();
  }
  close() {
    log7("closing the stream");
    void this.rest().sink([]).catch((err) => {
      log7.error(err);
    });
  }
};

// node_modules/libp2p/dist/src/circuit/circuit/stop.js
var log8 = logger("libp2p:circuit:stop");
function handleStop(options) {
  const { connection, request: request2, streamHandler } = options;
  try {
    validateAddrs(request2, streamHandler);
  } catch (err) {
    log8.error("invalid stop request via peer %p %o", connection.remotePeer, err);
    return;
  }
  log8("stop request is valid");
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  return streamHandler.rest();
}
async function stop(options) {
  const { connection, request: request2, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  log8("starting stop request to %p", connection.remotePeer);
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    streamHandler.close();
    return;
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log8("stop request to %p was successful", connection.remotePeer);
    return streamHandler.rest();
  }
  log8("stop request failed with code %d", response.code);
  streamHandler.close();
}

// node_modules/libp2p/dist/src/circuit/circuit/hop.js
var log9 = logger("libp2p:circuit:hop");
async function handleHop(hopRequest) {
  const { connection, request: request2, streamHandler, circuit, connectionManager } = hopRequest;
  if (!circuit.hopEnabled()) {
    log9("HOP request received but we are not acting as a relay");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
    });
  }
  try {
    validateAddrs(request2, streamHandler);
  } catch (err) {
    log9.error("invalid hop request via peer %p %o", connection.remotePeer, err);
    return;
  }
  if (request2.dstPeer == null) {
    log9("HOP request received but we do not receive a dstPeer");
    return;
  }
  const destinationPeer = peerIdFromBytes(request2.dstPeer.id);
  const destinationConnections = connectionManager.getConnections(destinationPeer);
  if (destinationConnections.length === 0 && !circuit.hopActive()) {
    log9("HOP request received but we are not connected to the destination peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  if (destinationConnections.length === 0) {
    log9("did not have connection to remote peer");
    return streamHandler.end({
      type: CircuitRelay.Type.STATUS,
      code: CircuitRelay.Status.HOP_NO_CONN_TO_DST
    });
  }
  const stopRequest = {
    type: CircuitRelay.Type.STOP,
    dstPeer: request2.dstPeer,
    srcPeer: request2.srcPeer
  };
  let destinationStream;
  try {
    log9("performing STOP request");
    const result = await stop({
      connection: destinationConnections[0],
      request: stopRequest
    });
    if (result == null) {
      throw new Error("Could not stop");
    }
    destinationStream = result;
  } catch (err) {
    log9.error(err);
    return;
  }
  log9("hop request from %p is valid", connection.remotePeer);
  streamHandler.write({
    type: CircuitRelay.Type.STATUS,
    code: CircuitRelay.Status.SUCCESS
  });
  const sourceStream = streamHandler.rest();
  log9("creating related connections");
  return await pipe(sourceStream, destinationStream, sourceStream);
}
async function hop(options) {
  const { connection, request: request2, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write(request2);
  const response = await streamHandler.read();
  if (response == null) {
    throw (0, import_err_code7.default)(new Error("HOP request had no response"), codes.ERR_HOP_REQUEST_FAILED);
  }
  if (response.code === CircuitRelay.Status.SUCCESS) {
    log9("hop request was successful");
    return streamHandler.rest();
  }
  log9("hop request failed with code %d, closing stream", response.code);
  streamHandler.close();
  throw (0, import_err_code7.default)(new Error(`HOP request failed with code "${response.code ?? "unknown"}"`), codes.ERR_HOP_REQUEST_FAILED);
}
async function canHop(options) {
  const { connection, signal } = options;
  const stream = await connection.newStream(RELAY_CODEC, {
    signal
  });
  const streamHandler = new StreamHandler({ stream });
  streamHandler.write({
    type: CircuitRelay.Type.CAN_HOP
  });
  const response = await streamHandler.read();
  await streamHandler.close();
  if (response == null || response.code !== CircuitRelay.Status.SUCCESS) {
    return false;
  }
  return true;
}
function handleCanHop(options) {
  const { connection, streamHandler, circuit } = options;
  const canHop2 = circuit.hopEnabled();
  log9("can hop (%s) request from %p", canHop2, connection.remotePeer);
  streamHandler.end({
    type: CircuitRelay.Type.STATUS,
    code: canHop2 ? CircuitRelay.Status.SUCCESS : CircuitRelay.Status.HOP_CANT_SPEAK_RELAY
  });
}

// node_modules/libp2p/dist/src/circuit/transport.js
var import_timeout_abort_controller3 = __toESM(require_timeout_abort_controller(), 1);
var import_events8 = __toESM(require_events(), 1);
var log10 = logger("libp2p:circuit");
var Circuit2 = class {
  constructor(components, init) {
    this._init = init;
    this.components = components;
    this._started = false;
  }
  isStarted() {
    return this._started;
  }
  async start() {
    if (this._started) {
      return;
    }
    this._started = true;
    await this.components.registrar.handle(RELAY_CODEC, (data) => {
      void this._onProtocol(data).catch((err) => {
        log10.error(err);
      });
    }).catch((err) => {
      log10.error(err);
    });
  }
  async stop() {
    await this.components.registrar.unhandle(RELAY_CODEC);
  }
  hopEnabled() {
    return true;
  }
  hopActive() {
    return true;
  }
  get [symbol2]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "libp2p/circuit-relay-v1";
  }
  async _onProtocol(data) {
    const { connection, stream } = data;
    const controller = new import_timeout_abort_controller3.TimeoutController(this._init.hop.timeout);
    try {
      (0, import_events8.setMaxListeners)?.(Infinity, controller.signal);
    } catch {
    }
    try {
      const source = abortableDuplex(stream, controller.signal);
      const streamHandler = new StreamHandler({
        stream: {
          ...stream,
          ...source
        }
      });
      const request2 = await streamHandler.read();
      if (request2 == null) {
        log10("request was invalid, could not read from stream");
        streamHandler.write({
          type: CircuitRelay.Type.STATUS,
          code: CircuitRelay.Status.MALFORMED_MESSAGE
        });
        streamHandler.close();
        return;
      }
      let virtualConnection;
      switch (request2.type) {
        case CircuitRelay.Type.CAN_HOP: {
          log10("received CAN_HOP request from %p", connection.remotePeer);
          await handleCanHop({ circuit: this, connection, streamHandler });
          break;
        }
        case CircuitRelay.Type.HOP: {
          log10("received HOP request from %p", connection.remotePeer);
          await handleHop({
            connection,
            request: request2,
            streamHandler,
            circuit: this,
            connectionManager: this.components.connectionManager
          });
          break;
        }
        case CircuitRelay.Type.STOP: {
          log10("received STOP request from %p", connection.remotePeer);
          virtualConnection = await handleStop({
            connection,
            request: request2,
            streamHandler
          });
          break;
        }
        default: {
          log10("Request of type %s not supported", request2.type);
          streamHandler.write({
            type: CircuitRelay.Type.STATUS,
            code: CircuitRelay.Status.MALFORMED_MESSAGE
          });
          streamHandler.close();
          return;
        }
      }
      if (virtualConnection != null) {
        const remoteAddr = connection.remoteAddr.encapsulate("/p2p-circuit").encapsulate(multiaddr(request2.dstPeer?.addrs[0]));
        const localAddr = multiaddr(request2.srcPeer?.addrs[0]);
        const maConn = streamToMaConnection({
          stream: virtualConnection,
          remoteAddr,
          localAddr
        });
        const type = request2.type === CircuitRelay.Type.HOP ? "relay" : "inbound";
        log10("new %s connection %s", type, maConn.remoteAddr);
        const conn = await this.components.upgrader.upgradeInbound(maConn);
        log10("%s connection %s upgraded", type, maConn.remoteAddr);
        if (this.handler != null) {
          this.handler(conn);
        }
      }
    } finally {
      controller.clear();
    }
  }
  async dial(ma, options = {}) {
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = "Circuit relay dial failed as addresses did not have peer id";
      log10.error(errMsg);
      throw (0, import_err_code8.default)(new Error(errMsg), codes.ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.components.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.components.peerStore.addressBook.add(relayPeer, [relayAddr]);
      relayConnection = await this.components.connectionManager.openConnection(relayPeer, options);
      disconnectOnFailure = true;
    }
    try {
      const virtualConnection = await hop({
        ...options,
        connection: relayConnection,
        request: {
          type: CircuitRelay.Type.HOP,
          srcPeer: {
            id: this.components.peerId.toBytes(),
            addrs: this.components.addressManager.getAddresses().map((addr) => addr.bytes)
          },
          dstPeer: {
            id: destinationPeer.toBytes(),
            addrs: [multiaddr(destinationAddr).bytes]
          }
        }
      });
      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.components.peerId.toString()}`);
      const maConn = streamToMaConnection({
        stream: virtualConnection,
        remoteAddr: ma,
        localAddr
      });
      log10("new outbound connection %s", maConn.remoteAddr);
      return await this.components.upgrader.upgradeOutbound(maConn);
    } catch (err) {
      log10.error("Circuit relay dial failed", err);
      disconnectOnFailure && await relayConnection.close();
      throw err;
    }
  }
  createListener(options) {
    this.handler = options.handler;
    return createListener({
      connectionManager: this.components.connectionManager,
      peerStore: this.components.peerStore
    });
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.matches(ma);
    });
  }
};

// node_modules/libp2p/dist/src/circuit/index.js
var import_set_delayed_interval2 = __toESM(require_src(), 1);

// node_modules/libp2p/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array2(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/libp2p/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe2(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array2(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/libp2p/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec3(name2, prefix, encode3, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: {
      decode: decode2
    }
  };
}
var string2 = createCodec3("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii2 = createCodec3("ascii", "a", (buf) => {
  let string6 = "a";
  for (let i = 0; i < buf.length; i++) {
    string6 += String.fromCharCode(buf[i]);
  }
  return string6;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe2(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
var BASES2 = {
  utf8: string2,
  "utf-8": string2,
  hex: bases.base16,
  latin1: ascii2,
  ascii: ascii2,
  binary: ascii2,
  ...bases
};
var bases_default2 = BASES2;

// node_modules/libp2p/node_modules/uint8arrays/dist/src/from-string.js
function fromString2(string6, encoding = "utf8") {
  const base = bases_default2[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array2(globalThis.Buffer.from(string6, "utf-8"));
  }
  return base.decoder.decode(`${base.prefix}${string6}`);
}

// node_modules/libp2p/node_modules/uint8arrays/dist/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base = bases_default2[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base.encoder.encode(array).substring(1);
}

// node_modules/libp2p/dist/src/circuit/utils.js
async function namespaceToCid(namespace) {
  const bytes = new TextEncoder().encode(namespace);
  const hash = await sha256.digest(bytes);
  return CID.createV0(hash);
}

// node_modules/libp2p/dist/src/circuit/constants.js
var minute = 60 * 1e3;
var ADVERTISE_BOOT_DELAY = 15 * minute;
var ADVERTISE_TTL = 30 * minute;
var CIRCUIT_PROTO_CODE = 290;
var HOP_METADATA_KEY = "hop_relay";
var HOP_METADATA_VALUE = "true";
var RELAY_RENDEZVOUS_NS = "/libp2p/relay";

// node_modules/@libp2p/utils/dist/src/multiaddr/is-private.js
var import_private_ip = __toESM(require_private_ip(), 1);
function isPrivate(ma) {
  const { address } = ma.nodeAddress();
  return Boolean((0, import_private_ip.default)(address));
}

// node_modules/@libp2p/utils/dist/src/address-sort.js
function publicAddressesFirst(a, b) {
  const isAPrivate = isPrivate(a.multiaddr);
  const isBPrivate = isPrivate(b.multiaddr);
  if (isAPrivate && !isBPrivate) {
    return 1;
  } else if (!isAPrivate && isBPrivate) {
    return -1;
  }
  if (a.isCertified && !b.isCertified) {
    return -1;
  } else if (!a.isCertified && b.isCertified) {
    return 1;
  }
  return 0;
}

// node_modules/libp2p/dist/src/circuit/auto-relay.js
var log11 = logger("libp2p:auto-relay");
var noop = () => {
};
var AutoRelay = class {
  constructor(components, init) {
    this.components = components;
    this.addressSorter = init.addressSorter ?? publicAddressesFirst;
    this.maxListeners = init.maxListeners ?? 1;
    this.listenRelays = /* @__PURE__ */ new Set();
    this.onError = init.onError ?? noop;
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
    this.components.peerStore.addEventListener("change:protocols", (evt) => {
      void this._onProtocolChange(evt).catch((err) => {
        log11.error(err);
      });
    });
    this.components.connectionManager.addEventListener("peer:disconnect", this._onPeerDisconnected);
  }
  async _onProtocolChange(evt) {
    const { peerId, protocols } = evt.detail;
    const id = peerId.toString();
    const hasProtocol = protocols.find((protocol) => protocol === RELAY_CODEC);
    if (hasProtocol == null) {
      if (this.listenRelays.has(id)) {
        await this._removeListenRelay(id);
      }
      return;
    }
    if (this.listenRelays.has(id)) {
      return;
    }
    try {
      const connections = this.components.connectionManager.getConnections(peerId);
      if (connections.length === 0) {
        return;
      }
      const connection = connections[0];
      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
        log11(`relayed connection to ${id} will not be used to hop on`);
        return;
      }
      const supportsHop = await canHop({ connection });
      if (supportsHop) {
        await this.components.peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, fromString2(HOP_METADATA_VALUE));
        await this._addListenRelay(connection, id);
      }
    } catch (err) {
      this.onError(err);
    }
  }
  _onPeerDisconnected(evt) {
    const connection = evt.detail;
    const peerId = connection.remotePeer;
    const id = peerId.toString();
    if (!this.listenRelays.has(id)) {
      return;
    }
    this._removeListenRelay(id).catch((err) => {
      log11.error(err);
    });
  }
  async _addListenRelay(connection, id) {
    try {
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
      const remoteAddrs = await pipe(await this.components.peerStore.addressBook.get(connection.remotePeer), (source) => sort(source, this.addressSorter), async (source) => await all2(source));
      const result = await Promise.all(remoteAddrs.map(async (addr) => {
        try {
          let multiaddr2 = addr.multiaddr;
          if (multiaddr2.getPeerId() == null) {
            multiaddr2 = multiaddr2.encapsulate(`/p2p/${connection.remotePeer.toString()}`);
          }
          multiaddr2 = multiaddr2.encapsulate("/p2p-circuit");
          await this.components.transportManager.listen([multiaddr2]);
          return true;
        } catch (err) {
          log11.error("error listening on circuit address", err);
          this.onError(err);
        }
        return false;
      }));
      if (result.includes(true)) {
        this.listenRelays.add(id);
      }
    } catch (err) {
      this.onError(err);
      this.listenRelays.delete(id);
    }
  }
  async _removeListenRelay(id) {
    if (this.listenRelays.delete(id)) {
      await this._listenOnAvailableHopRelays([id]);
    }
  }
  async _listenOnAvailableHopRelays(peersToIgnore = []) {
    if (this.listenRelays.size >= this.maxListeners) {
      return;
    }
    const knownHopsToDial = [];
    const peers = await this.components.peerStore.all();
    for (const { id, metadata } of peers) {
      const idStr = id.toString();
      if (this.listenRelays.has(idStr)) {
        continue;
      }
      if (peersToIgnore.includes(idStr)) {
        continue;
      }
      const supportsHop = metadata.get(HOP_METADATA_KEY);
      if (supportsHop == null || toString2(supportsHop) !== HOP_METADATA_VALUE) {
        continue;
      }
      const connections = this.components.connectionManager.getConnections(id);
      if (connections.length === 0) {
        knownHopsToDial.push(id);
        continue;
      }
      await this._addListenRelay(connections[0], idStr);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    for (const peerId of knownHopsToDial) {
      await this._tryToListenOnRelay(peerId);
      if (this.listenRelays.size >= this.maxListeners) {
        return;
      }
    }
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      for await (const provider of this.components.contentRouting.findProviders(cid)) {
        if (provider.multiaddrs.length === 0) {
          continue;
        }
        const peerId = provider.id;
        if (peerId.equals(this.components.peerId)) {
          continue;
        }
        await this.components.peerStore.addressBook.add(peerId, provider.multiaddrs);
        await this._tryToListenOnRelay(peerId);
        if (this.listenRelays.size >= this.maxListeners) {
          return;
        }
      }
    } catch (err) {
      this.onError(err);
    }
  }
  async _tryToListenOnRelay(peerId) {
    try {
      const connection = await this.components.connectionManager.openConnection(peerId);
      await this._addListenRelay(connection, peerId.toString());
    } catch (err) {
      log11.error("Could not use %p as relay", peerId, err);
      this.onError(err, `could not connect and listen on known hop relay ${peerId.toString()}`);
    }
  }
};

// node_modules/libp2p/dist/src/circuit/index.js
var log12 = logger("libp2p:relay");
var Relay = class {
  constructor(components, init) {
    this.components = components;
    this.autoRelay = init.autoRelay?.enabled !== false ? new AutoRelay(components, {
      addressSorter: init.addressSorter,
      ...init.autoRelay
    }) : void 0;
    this.started = false;
    this.init = init;
    this._advertiseService = this._advertiseService.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.init.hop.enabled !== false && this.init.advertise.enabled !== false) {
      this.timeout = (0, import_set_delayed_interval2.setDelayedInterval)(this._advertiseService, this.init.advertise.ttl, this.init.advertise.bootDelay);
    }
    this.started = true;
  }
  async stop() {
    if (this.timeout != null) {
      (0, import_set_delayed_interval2.clearDelayedInterval)(this.timeout);
    }
    this.started = false;
  }
  async _advertiseService() {
    try {
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      await this.components.contentRouting.provide(cid);
    } catch (err) {
      if (err.code === codes.ERR_NO_ROUTERS_AVAILABLE) {
        log12.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err);
        await this.stop();
      } else {
        log12.error(err);
      }
    }
  }
};

// node_modules/libp2p/dist/src/keychain/index.js
var import_sanitize_filename = __toESM(require_sanitize_filename(), 1);

// node_modules/libp2p/dist/src/keychain/cms.js
var import_pkcs7 = __toESM(require_pkcs7(), 1);
var import_pbe = __toESM(require_pbe(), 1);
var import_forge2 = __toESM(require_forge(), 1);

// node_modules/libp2p/dist/src/keychain/util.js
var import_x509 = __toESM(require_x509(), 1);
var import_forge = __toESM(require_forge(), 1);
var pki = import_forge.default.pki;
var certificateForKey = (key, privateKey) => {
  const publicKey = pki.rsa.setPublicKey(privateKey.n, privateKey.e);
  const cert = pki.createCertificate();
  cert.publicKey = publicKey;
  cert.serialNumber = "01";
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();
  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
  const attrs = [{
    name: "organizationName",
    value: "ipfs"
  }, {
    shortName: "OU",
    value: "keystore"
  }, {
    name: "commonName",
    value: key.id
  }];
  cert.setSubject(attrs);
  cert.setIssuer(attrs);
  cert.setExtensions([{
    name: "basicConstraints",
    cA: true
  }, {
    name: "keyUsage",
    keyCertSign: true,
    digitalSignature: true,
    nonRepudiation: true,
    keyEncipherment: true,
    dataEncipherment: true
  }, {
    name: "extKeyUsage",
    serverAuth: true,
    clientAuth: true,
    codeSigning: true,
    emailProtection: true,
    timeStamping: true
  }, {
    name: "nsCertType",
    client: true,
    server: true,
    email: true,
    objsign: true,
    sslCA: true,
    emailCA: true,
    objCA: true
  }]);
  cert.sign(privateKey);
  return cert;
};
async function findAsync(array, asyncCompare) {
  const promises = array.map(asyncCompare);
  const results = await Promise.all(promises);
  const index = results.findIndex((result) => result);
  return array[index];
}

// node_modules/libp2p/dist/src/keychain/cms.js
var import_err_code9 = __toESM(require_err_code(), 1);
var log13 = logger("libp2p:keychain:cms");
var privates = /* @__PURE__ */ new WeakMap();
var CMS = class {
  constructor(keychain, dek) {
    if (keychain == null) {
      throw (0, import_err_code9.default)(new Error("keychain is required"), codes.ERR_KEYCHAIN_REQUIRED);
    }
    this.keychain = keychain;
    privates.set(this, { dek });
  }
  async encrypt(name2, plain) {
    if (!(plain instanceof Uint8Array)) {
      throw (0, import_err_code9.default)(new Error("Plain data must be a Uint8Array"), codes.ERR_INVALID_PARAMETERS);
    }
    const key = await this.keychain.findKeyByName(name2);
    const pem = await this.keychain.getPrivateKey(name2);
    const cached = privates.get(this);
    if (cached == null) {
      throw (0, import_err_code9.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = import_forge2.default.pki.decryptRsaPrivateKey(pem, dek);
    const certificate = await certificateForKey(key, privateKey);
    const p7 = import_forge2.default.pkcs7.createEnvelopedData();
    p7.addRecipient(certificate);
    p7.content = import_forge2.default.util.createBuffer(plain);
    p7.encrypt();
    const der = import_forge2.default.asn1.toDer(p7.toAsn1()).getBytes();
    return fromString2(der, "ascii");
  }
  async decrypt(cmsData) {
    if (!(cmsData instanceof Uint8Array)) {
      throw (0, import_err_code9.default)(new Error("CMS data is required"), codes.ERR_INVALID_PARAMETERS);
    }
    let cms;
    try {
      const buf = import_forge2.default.util.createBuffer(toString2(cmsData, "ascii"));
      const obj = import_forge2.default.asn1.fromDer(buf);
      cms = import_forge2.default.pkcs7.messageFromAsn1(obj);
    } catch (err) {
      log13.error(err);
      throw (0, import_err_code9.default)(new Error("Invalid CMS"), codes.ERR_INVALID_CMS);
    }
    const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
      return {
        recipient: r2,
        keyId: r2.issuer.find((a) => a.shortName === "CN").value
      };
    });
    const r = await findAsync(recipients, async (recipient) => {
      try {
        const key2 = await this.keychain.findKeyById(recipient.keyId);
        if (key2 != null) {
          return true;
        }
      } catch (err) {
        return false;
      }
      return false;
    });
    if (r == null) {
      const missingKeys = recipients.map((r2) => r2.keyId);
      throw (0, import_err_code9.default)(new Error(`Decryption needs one of the key(s): ${missingKeys.join(", ")}`), codes.ERR_MISSING_KEYS, {
        missingKeys
      });
    }
    const key = await this.keychain.findKeyById(r.keyId);
    if (key == null) {
      throw (0, import_err_code9.default)(new Error("No key available to decrypto"), codes.ERR_NO_KEY);
    }
    const pem = await this.keychain.getPrivateKey(key.name);
    const cached = privates.get(this);
    if (cached == null) {
      throw (0, import_err_code9.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    const privateKey = import_forge2.default.pki.decryptRsaPrivateKey(pem, dek);
    cms.decrypt(r.recipient, privateKey);
    return fromString2(cms.content.getBytes(), "ascii");
  }
};

// node_modules/libp2p/dist/src/keychain/index.js
var import_err_code12 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/crypto/dist/src/aes/ciphers-browser.js
var import_aes = __toESM(require_aes(), 1);
var import_forge3 = __toESM(require_forge(), 1);

// node_modules/@libp2p/crypto/dist/src/aes/cipher-mode.js
var import_err_code10 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/crypto/dist/src/pbkdf2.js
var import_pbkdf2 = __toESM(require_pbkdf2(), 1);
var import_util5 = __toESM(require_util(), 1);
var import_err_code11 = __toESM(require_err_code(), 1);
var hashName = {
  sha1: "sha1",
  "sha2-256": "sha256",
  "sha2-512": "sha512"
};
function pbkdf2(password, salt, iterations, keySize, hash) {
  if (hash !== "sha1" && hash !== "sha2-256" && hash !== "sha2-512") {
    const types = Object.keys(hashName).join(" / ");
    throw (0, import_err_code11.default)(new Error(`Hash '${hash}' is unknown or not supported. Must be ${types}`), "ERR_UNSUPPORTED_HASH_TYPE");
  }
  const hasher = hashName[hash];
  const dek = (0, import_pbkdf2.default)(password, salt, iterations, keySize, hasher);
  return import_util5.default.encode64(dek, null);
}

// node_modules/libp2p/dist/src/keychain/index.js
var log14 = logger("libp2p:keychain");
var keyPrefix = "/pkcs8/";
var infoPrefix = "/info/";
var privates2 = /* @__PURE__ */ new WeakMap();
var NIST = {
  minKeyLength: 112 / 8,
  minSaltLength: 128 / 8,
  minIterationCount: 1e3
};
var defaultOptions3 = {
  dek: {
    keyLength: 512 / 8,
    iterationCount: 1e4,
    salt: "you should override this value with a crypto secure random number",
    hash: "sha2-512"
  }
};
function validateKeyName(name2) {
  if (name2 == null) {
    return false;
  }
  if (typeof name2 !== "string") {
    return false;
  }
  return name2 === (0, import_sanitize_filename.default)(name2.trim()) && name2.length > 0;
}
async function randomDelay() {
  const min = 200;
  const max = 1e3;
  const delay = Math.random() * (max - min) + min;
  await new Promise((resolve) => setTimeout(resolve, delay));
}
function DsName(name2) {
  return new Key(keyPrefix + name2);
}
function DsInfoName(name2) {
  return new Key(infoPrefix + name2);
}
var KeyChain = class {
  constructor(components, init) {
    this.components = components;
    this.init = merge_options_default(defaultOptions3, init);
    if (this.init.pass != null && this.init.pass?.length < 20) {
      throw new Error("pass must be least 20 characters");
    }
    if (this.init.dek?.keyLength != null && this.init.dek.keyLength < NIST.minKeyLength) {
      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
    }
    if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < NIST.minSaltLength) {
      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
    }
    if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < NIST.minIterationCount) {
      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
    }
    const dek = this.init.pass != null && this.init.dek?.salt != null ? pbkdf2(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates2.set(this, { dek });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const dsname = DsInfoName("self");
    if (!await this.components.datastore.has(dsname)) {
      await this.importPeer("self", this.components.peerId);
    }
    this.started = true;
  }
  stop() {
    this.started = false;
  }
  get cms() {
    const cached = privates2.get(this);
    if (cached == null) {
      throw (0, import_err_code12.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
    }
    const dek = cached.dek;
    return new CMS(this, dek);
  }
  static generateOptions() {
    const options = Object.assign({}, defaultOptions3);
    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
    options.dek.salt = toString2(randomBytes(saltLength), "base64");
    return options;
  }
  static get options() {
    return defaultOptions3;
  }
  async createKey(name2, type, size = 2048) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error("Invalid key name"), codes.ERR_INVALID_KEY_NAME);
    }
    if (typeof type !== "string") {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error("Invalid key type"), codes.ERR_INVALID_KEY_TYPE);
    }
    const dsname = DsName(name2);
    const exists = await this.components.datastore.has(dsname);
    if (exists) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error("Key name already exists"), codes.ERR_KEY_ALREADY_EXISTS);
    }
    switch (type.toLowerCase()) {
      case "rsa":
        if (!Number.isSafeInteger(size) || size < 2048) {
          await randomDelay();
          throw (0, import_err_code12.default)(new Error("Invalid RSA key size"), codes.ERR_INVALID_KEY_SIZE);
        }
        break;
      default:
        break;
    }
    let keyInfo;
    try {
      const keypair = await generateKeyPair(type, size);
      const kid = await keypair.id();
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code12.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await keypair.export(dek);
      keyInfo = {
        name: name2,
        id: kid
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString2(pem));
      batch.put(DsInfoName(name2), fromString2(JSON.stringify(keyInfo)));
      await batch.commit();
    } catch (err) {
      await randomDelay();
      throw err;
    }
    return keyInfo;
  }
  async listKeys() {
    const query = {
      prefix: infoPrefix
    };
    const info = [];
    for await (const value of this.components.datastore.query(query)) {
      info.push(JSON.parse(toString2(value.value)));
    }
    return info;
  }
  async findKeyById(id) {
    try {
      const keys = await this.listKeys();
      return keys.find((k) => k.id === id);
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  async findKeyByName(name2) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid key name '${name2}'`), codes.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsInfoName(name2);
    try {
      const res = await this.components.datastore.get(dsname);
      return JSON.parse(toString2(res));
    } catch (err) {
      await randomDelay();
      log14.error(err);
      throw (0, import_err_code12.default)(new Error(`Key '${name2}' does not exist.`), codes.ERR_KEY_NOT_FOUND);
    }
  }
  async removeKey(name2) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid key name '${name2}'`), codes.ERR_INVALID_KEY_NAME);
    }
    const dsname = DsName(name2);
    const keyInfo = await this.findKeyByName(name2);
    const batch = this.components.datastore.batch();
    batch.delete(dsname);
    batch.delete(DsInfoName(name2));
    await batch.commit();
    return keyInfo;
  }
  async renameKey(oldName, newName) {
    if (!validateKeyName(oldName) || oldName === "self") {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid old key name '${oldName}'`), codes.ERR_OLD_KEY_NAME_INVALID);
    }
    if (!validateKeyName(newName) || newName === "self") {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid new key name '${newName}'`), codes.ERR_NEW_KEY_NAME_INVALID);
    }
    const oldDsname = DsName(oldName);
    const newDsname = DsName(newName);
    const oldInfoName = DsInfoName(oldName);
    const newInfoName = DsInfoName(newName);
    const exists = await this.components.datastore.has(newDsname);
    if (exists) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Key '${newName}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);
    }
    try {
      const pem = await this.components.datastore.get(oldDsname);
      const res = await this.components.datastore.get(oldInfoName);
      const keyInfo = JSON.parse(toString2(res));
      keyInfo.name = newName;
      const batch = this.components.datastore.batch();
      batch.put(newDsname, pem);
      batch.put(newInfoName, fromString2(JSON.stringify(keyInfo)));
      batch.delete(oldDsname);
      batch.delete(oldInfoName);
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  async exportKey(name2, password) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid key name '${name2}'`), codes.ERR_INVALID_KEY_NAME);
    }
    if (password == null) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error("Password is required"), codes.ERR_PASSWORD_REQUIRED);
    }
    const dsname = DsName(name2);
    try {
      const res = await this.components.datastore.get(dsname);
      const pem = toString2(res);
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code12.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const privateKey = await importKey(pem, dek);
      return await privateKey.export(password);
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  async importKey(name2, pem, password) {
    if (!validateKeyName(name2) || name2 === "self") {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid key name '${name2}'`), codes.ERR_INVALID_KEY_NAME);
    }
    if (pem == null) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error("PEM encoded key is required"), codes.ERR_PEM_REQUIRED);
    }
    const dsname = DsName(name2);
    const exists = await this.components.datastore.has(dsname);
    if (exists) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Key '${name2}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);
    }
    let privateKey;
    try {
      privateKey = await importKey(pem, password);
    } catch (err) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error("Cannot read the key, most likely the password is wrong"), codes.ERR_CANNOT_READ_KEY);
    }
    let kid;
    try {
      kid = await privateKey.id();
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code12.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      pem = await privateKey.export(dek);
    } catch (err) {
      await randomDelay();
      throw err;
    }
    const keyInfo = {
      name: name2,
      id: kid
    };
    const batch = this.components.datastore.batch();
    batch.put(dsname, fromString2(pem));
    batch.put(DsInfoName(name2), fromString2(JSON.stringify(keyInfo)));
    await batch.commit();
    return keyInfo;
  }
  async importPeer(name2, peer) {
    try {
      if (!validateKeyName(name2)) {
        throw (0, import_err_code12.default)(new Error(`Invalid key name '${name2}'`), codes.ERR_INVALID_KEY_NAME);
      }
      if (peer == null) {
        throw (0, import_err_code12.default)(new Error("PeerId is required"), codes.ERR_MISSING_PRIVATE_KEY);
      }
      if (peer.privateKey == null) {
        throw (0, import_err_code12.default)(new Error("PeerId.privKey is required"), codes.ERR_MISSING_PRIVATE_KEY);
      }
      const privateKey = await unmarshalPrivateKey(peer.privateKey);
      const dsname = DsName(name2);
      const exists = await this.components.datastore.has(dsname);
      if (exists) {
        await randomDelay();
        throw (0, import_err_code12.default)(new Error(`Key '${name2}' already exists`), codes.ERR_KEY_ALREADY_EXISTS);
      }
      const cached = privates2.get(this);
      if (cached == null) {
        throw (0, import_err_code12.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
      }
      const dek = cached.dek;
      const pem = await privateKey.export(dek);
      const keyInfo = {
        name: name2,
        id: peer.toString()
      };
      const batch = this.components.datastore.batch();
      batch.put(dsname, fromString2(pem));
      batch.put(DsInfoName(name2), fromString2(JSON.stringify(keyInfo)));
      await batch.commit();
      return keyInfo;
    } catch (err) {
      await randomDelay();
      throw err;
    }
  }
  async getPrivateKey(name2) {
    if (!validateKeyName(name2)) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid key name '${name2}'`), codes.ERR_INVALID_KEY_NAME);
    }
    try {
      const dsname = DsName(name2);
      const res = await this.components.datastore.get(dsname);
      return toString2(res);
    } catch (err) {
      await randomDelay();
      log14.error(err);
      throw (0, import_err_code12.default)(new Error(`Key '${name2}' does not exist.`), codes.ERR_KEY_NOT_FOUND);
    }
  }
  async rotateKeychainPass(oldPass, newPass) {
    if (typeof oldPass !== "string") {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid old pass type '${typeof oldPass}'`), codes.ERR_INVALID_OLD_PASS_TYPE);
    }
    if (typeof newPass !== "string") {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid new pass type '${typeof newPass}'`), codes.ERR_INVALID_NEW_PASS_TYPE);
    }
    if (newPass.length < 20) {
      await randomDelay();
      throw (0, import_err_code12.default)(new Error(`Invalid pass length ${newPass.length}`), codes.ERR_INVALID_PASS_LENGTH);
    }
    log14("recreating keychain");
    const cached = privates2.get(this);
    if (cached == null) {
      throw (0, import_err_code12.default)(new Error("dek missing"), codes.ERR_INVALID_PARAMETERS);
    }
    const oldDek = cached.dek;
    this.init.pass = newPass;
    const newDek = newPass != null && this.init.dek?.salt != null ? pbkdf2(newPass, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
    privates2.set(this, { dek: newDek });
    const keys = await this.listKeys();
    for (const key of keys) {
      const res = await this.components.datastore.get(DsName(key.name));
      const pem = toString2(res);
      const privateKey = await importKey(pem, oldDek);
      const password = newDek.toString();
      const keyAsPEM = await privateKey.export(password);
      const batch = this.components.datastore.batch();
      const keyInfo = {
        name: key.name,
        id: key.id
      };
      batch.put(DsName(key.name), fromString2(keyAsPEM));
      batch.put(DsInfoName(key.name), fromString2(JSON.stringify(keyInfo)));
      await batch.commit();
    }
    log14("keychain reconstructed");
  }
};

// node_modules/it-foreach/dist/src/index.js
async function* forEach(source, fn) {
  for await (const thing of source) {
    await fn(thing);
    yield thing;
  }
}

// node_modules/libp2p/dist/src/metrics/index.js
var import_hashlru = __toESM(require_hashlru(), 1);

// node_modules/libp2p/dist/src/constants.js
var DIAL_TIMEOUT = 3e4;
var INBOUND_UPGRADE_TIMEOUT = 3e4;
var MAX_PARALLEL_DIALS = 100;
var MAX_PER_PEER_DIALS = 4;
var MAX_ADDRS_TO_DIAL = 25;
var METRICS = {
  computeThrottleMaxQueueSize: 1e3,
  computeThrottleTimeout: 2e3,
  movingAverageIntervals: [
    60 * 1e3,
    5 * 60 * 1e3,
    15 * 60 * 1e3
  ],
  maxOldPeersRetention: 50
};

// node_modules/libp2p/dist/src/metrics/moving-average.js
var DefaultMovingAverage = class {
  constructor(timespan) {
    if (typeof timespan !== "number") {
      throw new Error("must provide a timespan to the moving average constructor");
    }
    if (timespan <= 0) {
      throw new Error("must provide a timespan > 0 to the moving average constructor");
    }
    this.timespan = timespan;
    this.movingAverage = 0;
    this.variance = 0;
    this.deviation = 0;
    this.forecast = 0;
  }
  alpha(t, pt) {
    return 1 - Math.exp(-(t - pt) / this.timespan);
  }
  push(time, value) {
    if (this.previousTime != null) {
      const a = this.alpha(time, this.previousTime);
      const diff = value - this.movingAverage;
      const incr = a * diff;
      this.movingAverage = a * value + (1 - a) * this.movingAverage;
      this.variance = (1 - a) * (this.variance + diff * incr);
      this.deviation = Math.sqrt(this.variance);
      this.forecast = this.movingAverage + a * diff;
    } else {
      this.movingAverage = value;
    }
    this.previousTime = time;
  }
};
function createMovingAverage(timespan) {
  return new DefaultMovingAverage(timespan);
}

// node_modules/libp2p/dist/src/metrics/stats.js
var import_retimer3 = __toESM(require_retimer(), 1);
var DefaultStats = class extends EventEmitter {
  constructor(init) {
    super();
    this.enabled = init.enabled;
    this.queue = [];
    this.stats = {
      dataReceived: 0n,
      dataSent: 0n
    };
    this.frequencyLastTime = Date.now();
    this.frequencyAccumulators = {};
    this.movingAverages = {
      dataReceived: [],
      dataSent: []
    };
    this.computeThrottleMaxQueueSize = init.computeThrottleMaxQueueSize;
    this.computeThrottleTimeout = init.computeThrottleTimeout;
    this._update = this._update.bind(this);
    this.movingAverageIntervals = init.movingAverageIntervals;
    for (let i = 0; i < init.initialCounters.length; i++) {
      const key = init.initialCounters[i];
      this.stats[key] = 0n;
      this.movingAverages[key] = [];
      for (let k = 0; k < this.movingAverageIntervals.length; k++) {
        const interval = this.movingAverageIntervals[k];
        const ma = this.movingAverages[key][interval] = createMovingAverage(interval);
        ma.push(this.frequencyLastTime, 0);
      }
    }
  }
  start() {
    if (!this.enabled) {
      return;
    }
    if (this.queue.length > 0) {
      this._resetComputeTimeout();
    }
  }
  stop() {
    if (this.timeout != null) {
      this.timeout.clear();
      this.timeout = null;
    }
  }
  getSnapshot() {
    return Object.assign({}, this.stats);
  }
  getMovingAverages() {
    return Object.assign({}, this.movingAverages);
  }
  push(counter, inc) {
    this.queue.push([counter, inc, Date.now()]);
    this._resetComputeTimeout();
  }
  _resetComputeTimeout() {
    this.timeout = (0, import_retimer3.default)(this._update, this._nextTimeout());
  }
  _nextTimeout() {
    const urgency = this.queue.length / this.computeThrottleMaxQueueSize;
    const timeout = Math.max(this.computeThrottleTimeout * (1 - urgency), 0);
    return timeout;
  }
  _update() {
    this.timeout = null;
    if (this.queue.length > 0) {
      let last = ["", 0, 0];
      for (last of this.queue) {
        this._applyOp(last);
      }
      this.queue = [];
      if (last.length > 2 && last[0] !== "") {
        this._updateFrequency(last[2]);
      }
      this.dispatchEvent(new CustomEvent("update", {
        detail: this.stats
      }));
    }
  }
  _updateFrequency(latestTime) {
    const timeDiff = latestTime - this.frequencyLastTime;
    this._updateFrequencyFor("dataReceived", timeDiff, latestTime);
    this._updateFrequencyFor("dataSent", timeDiff, latestTime);
    this.frequencyLastTime = latestTime;
  }
  _updateFrequencyFor(key, timeDiffMS, latestTime) {
    const count = this.frequencyAccumulators[key] ?? 0;
    this.frequencyAccumulators[key] = 0;
    const safeTimeDiff = timeDiffMS ?? 1;
    const hz = count / safeTimeDiff * 1e3;
    let movingAverages = this.movingAverages[key];
    if (movingAverages == null) {
      movingAverages = this.movingAverages[key] = [];
    }
    const intervals = this.movingAverageIntervals;
    for (let i = 0; i < intervals.length; i++) {
      const movingAverageInterval = intervals[i];
      let movingAverage = movingAverages[movingAverageInterval];
      if (movingAverage == null) {
        movingAverage = movingAverages[movingAverageInterval] = createMovingAverage(movingAverageInterval);
      }
      movingAverage.push(latestTime, hz);
    }
  }
  _applyOp(op) {
    const key = op[0];
    const inc = op[1];
    if (typeof inc !== "number") {
      throw new Error("invalid increment number");
    }
    let n;
    if (!Object.prototype.hasOwnProperty.call(this.stats, key)) {
      n = this.stats[key] = 0n;
    } else {
      n = this.stats[key];
    }
    this.stats[key] = n + BigInt(inc);
    if (this.frequencyAccumulators[key] == null) {
      this.frequencyAccumulators[key] = 0;
    }
    this.frequencyAccumulators[key] += inc;
  }
};

// node_modules/libp2p/dist/src/metrics/index.js
var initialCounters = [
  "dataReceived",
  "dataSent"
];
var directionToEvent = {
  in: "dataReceived",
  out: "dataSent"
};
var DefaultMetrics = class {
  constructor(init) {
    this.enabled = init.enabled;
    this.statsInit = {
      ...init,
      initialCounters
    };
    this.globalStats = new DefaultStats(this.statsInit);
    this.peerStats = /* @__PURE__ */ new Map();
    this.protocolStats = /* @__PURE__ */ new Map();
    this.oldPeers = (0, import_hashlru.default)(init.maxOldPeersRetention ?? METRICS.maxOldPeersRetention);
    this.running = false;
    this._onMessage = this._onMessage.bind(this);
    this.systems = /* @__PURE__ */ new Map();
  }
  isStarted() {
    return this.running;
  }
  async start() {
    if (!this.enabled) {
      return;
    }
    this.running = true;
  }
  async stop() {
    if (!this.running) {
      return;
    }
    this.running = false;
    this.globalStats.stop();
    for (const stats of this.peerStats.values()) {
      stats.stop();
    }
    for (const stats of this.protocolStats.values()) {
      stats.stop();
    }
  }
  getGlobal() {
    return this.globalStats;
  }
  getPeers() {
    return Array.from(this.peerStats.keys());
  }
  getComponentMetrics() {
    return this.systems;
  }
  updateComponentMetric(update) {
    const { system = "libp2p", component, metric, value, label, help } = update;
    if (!this.systems.has(system)) {
      this.systems.set(system, /* @__PURE__ */ new Map());
    }
    const systemMetrics = this.systems.get(system);
    if (systemMetrics == null) {
      throw new Error("Unknown metric system");
    }
    if (!systemMetrics.has(component)) {
      systemMetrics.set(component, /* @__PURE__ */ new Map());
    }
    const componentMetrics = systemMetrics.get(component);
    if (componentMetrics == null) {
      throw new Error("Unknown metric component");
    }
    componentMetrics.set(metric, {
      label,
      help,
      calculate: typeof value !== "function" ? () => value : value
    });
  }
  forPeer(peerId) {
    const idString = peerId.toString();
    return this.peerStats.get(idString) ?? this.oldPeers.get(idString);
  }
  getProtocols() {
    return Array.from(this.protocolStats.keys());
  }
  forProtocol(protocol) {
    return this.protocolStats.get(protocol);
  }
  onPeerDisconnected(peerId) {
    const idString = peerId.toString();
    const peerStats = this.peerStats.get(idString);
    if (peerStats != null) {
      peerStats.stop();
      this.peerStats.delete(idString);
      this.oldPeers.set(idString, peerStats);
    }
  }
  _onMessage(opts) {
    if (!this.running) {
      return;
    }
    const { remotePeer, protocol, direction, dataLength } = opts;
    const key = directionToEvent[direction];
    let peerStats = this.forPeer(remotePeer);
    if (peerStats == null) {
      const stats = new DefaultStats(this.statsInit);
      this.peerStats.set(remotePeer.toString(), stats);
      peerStats = stats;
    }
    peerStats.push(key, dataLength);
    this.globalStats.push(key, dataLength);
    if (protocol != null) {
      let protocolStats = this.forProtocol(protocol);
      if (protocolStats == null) {
        const stats = new DefaultStats(this.statsInit);
        this.protocolStats.set(protocol, stats);
        protocolStats = stats;
      }
      protocolStats.push(key, dataLength);
    }
  }
  updatePlaceholder(placeholder, peerId) {
    if (!this.running) {
      return;
    }
    const placeholderString = placeholder.toString();
    const placeholderStats = this.peerStats.get(placeholderString) ?? this.oldPeers.get(placeholderString);
    const peerIdString = peerId.toString();
    const existingStats = this.peerStats.get(peerIdString) ?? this.oldPeers.get(peerIdString);
    let mergedStats = placeholderStats;
    if (existingStats != null) {
      mergedStats = mergeStats(existingStats, mergedStats);
      this.oldPeers.remove(peerIdString);
    }
    this.peerStats.delete(placeholder.toString());
    this.peerStats.set(peerIdString, mergedStats);
    mergedStats.start();
  }
  trackStream(opts) {
    const { stream, remotePeer, protocol } = opts;
    if (!this.running) {
      return;
    }
    const source = stream.source;
    stream.source = forEach(source, (chunk) => this._onMessage({
      remotePeer,
      protocol,
      direction: "in",
      dataLength: chunk.byteLength
    }));
    const sink = stream.sink;
    stream.sink = async (source2) => {
      return await pipe(source2, (source3) => forEach(source3, (chunk) => {
        this._onMessage({
          remotePeer,
          protocol,
          direction: "out",
          dataLength: chunk.byteLength
        });
      }), sink);
    };
  }
};
function mergeStats(target, other) {
  target.stop();
  other.stop();
  target.queue = [...target.queue, ...other.queue];
  return target;
}

// node_modules/p-reflect/index.js
async function pReflect(promise) {
  try {
    const value = await promise;
    return {
      status: "fulfilled",
      value,
      isFulfilled: true,
      isRejected: false
    };
  } catch (error) {
    return {
      status: "rejected",
      reason: error,
      isFulfilled: false,
      isRejected: true
    };
  }
}

// node_modules/yocto-queue/index.js
var Node = class {
  constructor(value) {
    __publicField(this, "value");
    __publicField(this, "next");
    this.value = value;
  }
};
var _head, _tail, _size;
var Queue = class {
  constructor() {
    __privateAdd(this, _head, void 0);
    __privateAdd(this, _tail, void 0);
    __privateAdd(this, _size, void 0);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    return current.value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
};
_head = new WeakMap();
_tail = new WeakMap();
_size = new WeakMap();

// node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
  const queue = new Queue();
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue.size > 0) {
      queue.dequeue()();
    }
  };
  const run = async (fn, resolve, args) => {
    activeCount++;
    const result = (async () => fn(...args))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (fn, resolve, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve, args));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency && queue.size > 0) {
        queue.dequeue()();
      }
    })();
  };
  const generator = (fn, ...args) => new Promise((resolve) => {
    enqueue(fn, resolve, args);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  });
  return generator;
}

// node_modules/p-settle/index.js
async function pSettle(array, options = {}) {
  const { concurrency = Number.POSITIVE_INFINITY } = options;
  const limit = pLimit(concurrency);
  return Promise.all(array.map((element) => {
    if (element && typeof element.then === "function") {
      return pReflect(element);
    }
    if (typeof element === "function") {
      return pReflect(limit(() => element()));
    }
    return pReflect(Promise.resolve(element));
  }));
}

// node_modules/libp2p/dist/src/transport-manager.js
var import_err_code13 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/tracked-map/dist/src/index.js
var TrackedMap = class extends Map {
  constructor(init) {
    super();
    const { system, component, metric, metrics } = init;
    this.system = system ?? "libp2p";
    this.component = component;
    this.metric = metric;
    this.metrics = metrics;
    this.updateComponentMetric();
  }
  set(key, value) {
    super.set(key, value);
    this.updateComponentMetric();
    return this;
  }
  delete(key) {
    const deleted = super.delete(key);
    this.updateComponentMetric();
    return deleted;
  }
  clear() {
    super.clear();
    this.updateComponentMetric();
  }
  updateComponentMetric() {
    this.metrics.updateComponentMetric({
      system: this.system,
      component: this.component,
      metric: this.metric,
      value: this.size
    });
  }
};
function trackedMap(config) {
  const { system, component, metric, metrics } = config;
  let map3;
  if (metrics != null) {
    map3 = new TrackedMap({ system, component, metric, metrics });
  } else {
    map3 = /* @__PURE__ */ new Map();
  }
  return map3;
}

// node_modules/libp2p/dist/src/transport-manager.js
var log15 = logger("libp2p:transports");
var DefaultTransportManager = class extends EventEmitter {
  constructor(components, init = {}) {
    super();
    this.components = components;
    this.started = false;
    this.transports = /* @__PURE__ */ new Map();
    this.listeners = trackedMap({
      component: "transport-manager",
      metric: "listeners",
      metrics: this.components.metrics
    });
    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL;
  }
  add(transport) {
    const tag = transport[Symbol.toStringTag];
    if (tag == null) {
      throw (0, import_err_code13.default)(new Error("Transport must have a valid tag"), codes.ERR_INVALID_KEY);
    }
    if (this.transports.has(tag)) {
      throw (0, import_err_code13.default)(new Error("There is already a transport with this tag"), codes.ERR_DUPLICATE_TRANSPORT);
    }
    log15("adding transport %s", tag);
    this.transports.set(tag, transport);
    if (!this.listeners.has(tag)) {
      this.listeners.set(tag, []);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    const addrs = this.components.addressManager.getListenAddrs();
    await this.listen(addrs);
    this.started = true;
  }
  async stop() {
    const tasks = [];
    for (const [key, listeners] of this.listeners) {
      log15("closing listeners for %s", key);
      while (listeners.length > 0) {
        const listener = listeners.pop();
        if (listener == null) {
          continue;
        }
        tasks.push(listener.close());
      }
    }
    await Promise.all(tasks);
    log15("all listeners closed");
    for (const key of this.listeners.keys()) {
      this.listeners.set(key, []);
    }
    this.started = false;
  }
  async dial(ma, options) {
    const transport = this.transportForMultiaddr(ma);
    if (transport == null) {
      throw (0, import_err_code13.default)(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);
    }
    try {
      return await transport.dial(ma, {
        ...options,
        upgrader: this.components.upgrader
      });
    } catch (err) {
      if (err.code == null) {
        err.code = codes.ERR_TRANSPORT_DIAL_FAILED;
      }
      throw err;
    }
  }
  getAddrs() {
    let addrs = [];
    for (const listeners of this.listeners.values()) {
      for (const listener of listeners) {
        addrs = [...addrs, ...listener.getAddrs()];
      }
    }
    return addrs;
  }
  getTransports() {
    return Array.of(...this.transports.values());
  }
  transportForMultiaddr(ma) {
    for (const transport of this.transports.values()) {
      const addrs = transport.filter([ma]);
      if (addrs.length > 0) {
        return transport;
      }
    }
  }
  async listen(addrs) {
    if (addrs == null || addrs.length === 0) {
      log15("no addresses were provided for listening, this node is dial only");
      return;
    }
    const couldNotListen = [];
    for (const [key, transport] of this.transports.entries()) {
      const supportedAddrs = transport.filter(addrs);
      const tasks = [];
      for (const addr of supportedAddrs) {
        log15("creating listener for %s on %s", key, addr);
        const listener = transport.createListener({
          upgrader: this.components.upgrader
        });
        let listeners = this.listeners.get(key);
        if (listeners == null) {
          listeners = [];
          this.listeners.set(key, listeners);
        }
        listeners.push(listener);
        listener.addEventListener("listening", () => {
          this.dispatchEvent(new CustomEvent("listener:listening", {
            detail: listener
          }));
        });
        listener.addEventListener("close", () => {
          this.dispatchEvent(new CustomEvent("listener:close", {
            detail: listener
          }));
        });
        tasks.push(listener.listen(addr));
      }
      if (tasks.length === 0) {
        couldNotListen.push(key);
        continue;
      }
      const results = await pSettle(tasks);
      const isListening = results.find((r) => r.isFulfilled);
      if (isListening == null && this.faultTolerance !== FaultTolerance.NO_FATAL) {
        throw (0, import_err_code13.default)(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);
      }
    }
    if (couldNotListen.length === this.transports.size) {
      const message5 = `no valid addresses were provided for transports [${couldNotListen.join(", ")}]`;
      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {
        throw (0, import_err_code13.default)(new Error(message5), codes.ERR_NO_VALID_ADDRESSES);
      }
      log15(`libp2p in dial mode only: ${message5}`);
    }
  }
  async remove(key) {
    log15("removing %s", key);
    for (const listener of this.listeners.get(key) ?? []) {
      await listener.close();
    }
    this.transports.delete(key);
    this.listeners.delete(key);
  }
  async removeAll() {
    const tasks = [];
    for (const key of this.transports.keys()) {
      tasks.push(this.remove(key));
    }
    await Promise.all(tasks);
  }
};
var FaultTolerance;
(function(FaultTolerance2) {
  FaultTolerance2[FaultTolerance2["FATAL_ALL"] = 0] = "FATAL_ALL";
  FaultTolerance2[FaultTolerance2["NO_FATAL"] = 1] = "NO_FATAL";
})(FaultTolerance || (FaultTolerance = {}));

// node_modules/libp2p/dist/src/upgrader.js
var import_err_code18 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/multistream-select/dist/src/constants.js
var PROTOCOL_ID = "/multistream/1.0.0";

// node_modules/@libp2p/multistream-select/dist/src/select.js
var import_err_code15 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var import_err_code14 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array3(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe3(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array3(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec4(name2, prefix, encode3, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: {
      decode: decode2
    }
  };
}
var string3 = createCodec4("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii3 = createCodec4("ascii", "a", (buf) => {
  let string6 = "a";
  for (let i = 0; i < buf.length; i++) {
    string6 += String.fromCharCode(buf[i]);
  }
  return string6;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe3(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
var BASES3 = {
  utf8: string3,
  "utf-8": string3,
  hex: bases.base16,
  latin1: ascii3,
  ascii: ascii3,
  binary: ascii3,
  ...bases
};
var bases_default3 = BASES3;

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/from-string.js
function fromString4(string6, encoding = "utf8") {
  const base = bases_default3[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array3(globalThis.Buffer.from(string6, "utf-8"));
  }
  return base.decoder.decode(`${base.prefix}${string6}`);
}

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var import_it_first2 = __toESM(require_it_first(), 1);

// node_modules/@libp2p/multistream-select/node_modules/uint8arrays/dist/src/to-string.js
function toString4(array, encoding = "utf8") {
  const base = bases_default3[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base.encoder.encode(array).substring(1);
}

// node_modules/@libp2p/multistream-select/dist/src/multistream.js
var NewLine = fromString4("\n");
function encode2(buffer) {
  const list = new Uint8ArrayList(buffer, NewLine);
  return encode.single(list);
}
function write(writer5, buffer, options = {}) {
  const encoded = encode2(buffer);
  if (options.writeBytes === true) {
    writer5.push(encoded.subarray());
  } else {
    writer5.push(encoded);
  }
}
function writeAll(writer5, buffers, options = {}) {
  const list = new Uint8ArrayList();
  for (const buf of buffers) {
    list.append(encode2(buf));
  }
  if (options.writeBytes === true) {
    writer5.push(list.subarray());
  } else {
    writer5.push(list);
  }
}
async function read(reader6, options) {
  let byteLength = 1;
  const varByteSource = {
    [Symbol.asyncIterator]: () => varByteSource,
    next: async () => await reader6.next(byteLength)
  };
  let input = varByteSource;
  if (options?.signal != null) {
    input = abortableSource(varByteSource, options.signal);
  }
  const onLength = (l) => {
    byteLength = l;
  };
  const buf = await pipe(input, decode({ onLength }), async (source) => await (0, import_it_first2.default)(source));
  if (buf == null) {
    throw (0, import_err_code14.default)(new Error("no buffer returned"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  if (buf.get(buf.byteLength - 1) !== NewLine[0]) {
    throw (0, import_err_code14.default)(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
  }
  return buf.sublist(0, -1);
}
async function readString(reader6, options) {
  const buf = await read(reader6, options);
  return toString4(buf.subarray());
}

// node_modules/@libp2p/multistream-select/dist/src/select.js
var import_it_merge3 = __toESM(require_it_merge(), 1);
var log16 = logger("libp2p:mss:select");
async function select(stream, protocols, options = {}) {
  protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
  const { reader: reader6, writer: writer5, rest, stream: shakeStream } = handshake(stream);
  const protocol = protocols.shift();
  if (protocol == null) {
    throw new Error("At least one protocol must be specified");
  }
  log16('select: write ["%s", "%s"]', PROTOCOL_ID, protocol);
  const p1 = fromString4(PROTOCOL_ID);
  const p2 = fromString4(protocol);
  writeAll(writer5, [p1, p2], options);
  let response = await readString(reader6, options);
  log16('select: read "%s"', response);
  if (response === PROTOCOL_ID) {
    response = await readString(reader6, options);
    log16('select: read "%s"', response);
  }
  if (response === protocol) {
    rest();
    return { stream: shakeStream, protocol };
  }
  for (const protocol2 of protocols) {
    log16('select: write "%s"', protocol2);
    write(writer5, fromString4(protocol2), options);
    const response2 = await readString(reader6, options);
    log16('select: read "%s" for "%s"', response2, protocol2);
    if (response2 === protocol2) {
      rest();
      return { stream: shakeStream, protocol: protocol2 };
    }
  }
  rest();
  throw (0, import_err_code15.default)(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
}

// node_modules/@libp2p/multistream-select/dist/src/handle.js
var log17 = logger("libp2p:mss:handle");
async function handle(stream, protocols, options) {
  protocols = Array.isArray(protocols) ? protocols : [protocols];
  const { writer: writer5, reader: reader6, rest, stream: shakeStream } = handshake(stream);
  while (true) {
    const protocol = await readString(reader6, options);
    log17('read "%s"', protocol);
    if (protocol === PROTOCOL_ID) {
      log17('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
      write(writer5, fromString4(PROTOCOL_ID), options);
      continue;
    }
    if (protocols.includes(protocol)) {
      write(writer5, fromString4(protocol), options);
      log17('respond with "%s" for "%s"', protocol, protocol);
      rest();
      return { stream: shakeStream, protocol };
    }
    if (protocol === "ls") {
      write(writer5, new Uint8ArrayList(...protocols.map((p) => encode2(fromString4(p)))), options);
      log17('respond with "%s" for %s', protocols, protocol);
      continue;
    }
    write(writer5, fromString4("na"), options);
    log17('respond with "na" for "%s"', protocol);
  }
}

// node_modules/libp2p/dist/src/upgrader.js
var import_mutable_proxy = __toESM(require_build(), 1);

// node_modules/@libp2p/connection/dist/src/index.js
var import_err_code16 = __toESM(require_err_code());

// node_modules/@libp2p/interface-connection/dist/src/index.js
var symbol3 = Symbol.for("@libp2p/connection");

// node_modules/@libp2p/connection/dist/src/index.js
var log18 = logger("libp2p:connection");
var ConnectionImpl = class {
  constructor(init) {
    const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init;
    this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`;
    this.remoteAddr = remoteAddr;
    this.remotePeer = remotePeer;
    this.stat = {
      ...stat,
      status: OPEN
    };
    this._newStream = newStream;
    this._close = close;
    this._getStreams = getStreams;
    this.tags = [];
    this._closing = false;
  }
  get [Symbol.toStringTag]() {
    return "Connection";
  }
  get [symbol3]() {
    return true;
  }
  get streams() {
    return this._getStreams();
  }
  async newStream(protocols, options) {
    if (this.stat.status === CLOSING) {
      throw (0, import_err_code16.default)(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
    }
    if (this.stat.status === CLOSED) {
      throw (0, import_err_code16.default)(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
    }
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    const stream = await this._newStream(protocols, options);
    stream.stat.direction = "outbound";
    return stream;
  }
  addStream(stream) {
    stream.stat.direction = "inbound";
  }
  removeStream(id) {
  }
  async close() {
    if (this.stat.status === CLOSED || this._closing) {
      return;
    }
    this.stat.status = CLOSING;
    try {
      this.streams.forEach((s) => s.close());
    } catch (err) {
      log18.error(err);
    }
    this._closing = true;
    await this._close();
    this._closing = false;
    this.stat.timeline.close = Date.now();
    this.stat.status = CLOSED;
  }
};
function createConnection(init) {
  return new ConnectionImpl(init);
}

// node_modules/libp2p/dist/src/registrar.js
var import_err_code17 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/interface-registrar/dist/src/index.js
var topologySymbol = Symbol.for("@libp2p/topology");
function isTopology(other) {
  return other != null && Boolean(other[topologySymbol]);
}

// node_modules/libp2p/dist/src/registrar.js
var log19 = logger("libp2p:registrar");
var DEFAULT_MAX_INBOUND_STREAMS = 32;
var DEFAULT_MAX_OUTBOUND_STREAMS = 64;
var DefaultRegistrar = class {
  constructor(components) {
    this.topologies = /* @__PURE__ */ new Map();
    this.handlers = /* @__PURE__ */ new Map();
    this.components = components;
    this._onDisconnect = this._onDisconnect.bind(this);
    this._onProtocolChange = this._onProtocolChange.bind(this);
    this.components.connectionManager.addEventListener("peer:disconnect", this._onDisconnect);
    this.components.peerStore.addEventListener("change:protocols", this._onProtocolChange);
  }
  getProtocols() {
    return Array.from(/* @__PURE__ */ new Set([
      ...this.topologies.keys(),
      ...this.handlers.keys()
    ])).sort();
  }
  getHandler(protocol) {
    const handler = this.handlers.get(protocol);
    if (handler == null) {
      throw (0, import_err_code17.default)(new Error(`No handler registered for protocol ${protocol}`), codes.ERR_NO_HANDLER_FOR_PROTOCOL);
    }
    return handler;
  }
  getTopologies(protocol) {
    const topologies = this.topologies.get(protocol);
    if (topologies == null) {
      return [];
    }
    return [
      ...topologies.values()
    ];
  }
  async handle(protocol, handler, opts) {
    if (this.handlers.has(protocol)) {
      throw (0, import_err_code17.default)(new Error(`Handler already registered for protocol ${protocol}`), codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
    }
    const options = merge_options_default.bind({ ignoreUndefined: true })({
      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,
      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS
    }, opts);
    this.handlers.set(protocol, {
      handler,
      options
    });
    await this.components.peerStore.protoBook.add(this.components.peerId, [protocol]);
  }
  async unhandle(protocols) {
    const protocolList = Array.isArray(protocols) ? protocols : [protocols];
    protocolList.forEach((protocol) => {
      this.handlers.delete(protocol);
    });
    await this.components.peerStore.protoBook.remove(this.components.peerId, protocolList);
  }
  async register(protocol, topology) {
    if (!isTopology(topology)) {
      log19.error("topology must be an instance of interfaces/topology");
      throw (0, import_err_code17.default)(new Error("topology must be an instance of interfaces/topology"), codes.ERR_INVALID_PARAMETERS);
    }
    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
    let topologies = this.topologies.get(protocol);
    if (topologies == null) {
      topologies = /* @__PURE__ */ new Map();
      this.topologies.set(protocol, topologies);
    }
    topologies.set(id, topology);
    await topology.setRegistrar(this);
    return id;
  }
  unregister(id) {
    for (const [protocol, topologies] of this.topologies.entries()) {
      if (topologies.has(id)) {
        topologies.delete(id);
        if (topologies.size === 0) {
          this.topologies.delete(protocol);
        }
      }
    }
  }
  _onDisconnect(evt) {
    const connection = evt.detail;
    void this.components.peerStore.protoBook.get(connection.remotePeer).then((peerProtocols) => {
      for (const protocol of peerProtocols) {
        const topologies = this.topologies.get(protocol);
        if (topologies == null) {
          continue;
        }
        for (const topology of topologies.values()) {
          topology.onDisconnect(connection.remotePeer);
        }
      }
    }).catch((err) => {
      log19.error(err);
    });
  }
  _onProtocolChange(evt) {
    const { peerId, protocols, oldProtocols } = evt.detail;
    const removed = oldProtocols.filter((protocol) => !protocols.includes(protocol));
    const added = protocols.filter((protocol) => !oldProtocols.includes(protocol));
    for (const protocol of removed) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        topology.onDisconnect(peerId);
      }
    }
    for (const protocol of added) {
      const topologies = this.topologies.get(protocol);
      if (topologies == null) {
        continue;
      }
      for (const topology of topologies.values()) {
        const connection = this.components.connectionManager.getConnections(peerId)[0];
        if (connection == null) {
          continue;
        }
        topology.onConnect(peerId, connection);
      }
    }
  }
};

// node_modules/libp2p/dist/src/upgrader.js
var import_timeout_abort_controller4 = __toESM(require_timeout_abort_controller(), 1);
var import_events12 = __toESM(require_events(), 1);
var log20 = logger("libp2p:upgrader");
function findIncomingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxInboundStreams;
  } catch (err) {
    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err;
    }
  }
  return DEFAULT_MAX_INBOUND_STREAMS;
}
function findOutgoingStreamLimit(protocol, registrar) {
  try {
    const { options } = registrar.getHandler(protocol);
    return options.maxOutboundStreams;
  } catch (err) {
    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {
      throw err;
    }
  }
  return DEFAULT_MAX_OUTBOUND_STREAMS;
}
function countStreams(protocol, direction, connection) {
  let streamCount = 0;
  connection.streams.forEach((stream) => {
    if (stream.stat.direction === direction && stream.stat.protocol === protocol) {
      streamCount++;
    }
  });
  return streamCount;
}
var DefaultUpgrader = class extends EventEmitter {
  constructor(components, init) {
    super();
    this.components = components;
    this.connectionEncryption = /* @__PURE__ */ new Map();
    init.connectionEncryption.forEach((encrypter) => {
      this.connectionEncryption.set(encrypter.protocol, encrypter);
    });
    this.muxers = /* @__PURE__ */ new Map();
    init.muxers.forEach((muxer) => {
      this.muxers.set(muxer.protocol, muxer);
    });
    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout;
  }
  async upgradeInbound(maConn) {
    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn);
    if (!accept) {
      throw (0, import_err_code18.default)(new Error("connection denied"), codes.ERR_CONNECTION_DENIED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let muxerFactory;
    let cryptoProtocol;
    let setPeer;
    let proxyPeer;
    const metrics = this.components.metrics;
    const timeoutController = new import_timeout_abort_controller4.TimeoutController(this.inboundUpgradeTimeout);
    try {
      (0, import_events12.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const abortableStream = abortableDuplex(maConn, timeoutController.signal);
      maConn.source = abortableStream.source;
      maConn.sink = abortableStream.sink;
      if (await this.components.connectionGater.denyInboundConnection(maConn)) {
        throw (0, import_err_code18.default)(new Error("The multiaddr connection is blocked by gater.acceptConnection"), codes.ERR_CONNECTION_INTERCEPTED);
      }
      if (metrics != null) {
        ({ setTarget: setPeer, proxy: proxyPeer } = (0, import_mutable_proxy.default)());
        const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
        setPeer({ toString: () => idString });
        metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
      }
      log20("starting the inbound connection upgrade");
      let protectedConn = maConn;
      const protector = this.components.connectionProtector;
      if (protector != null) {
        log20("protecting the inbound connection");
        protectedConn = await protector.protect(maConn);
      }
      try {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptInbound(protectedConn));
        if (await this.components.connectionGater.denyInboundEncryptedConnection(remotePeer, {
          ...protectedConn,
          ...encryptedConn
        })) {
          throw (0, import_err_code18.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
        }
        if (this.muxers.size > 0) {
          const multiplexed = await this._multiplexInbound({
            ...protectedConn,
            ...encryptedConn
          }, this.muxers);
          muxerFactory = multiplexed.muxerFactory;
          upgradedConn = multiplexed.stream;
        } else {
          upgradedConn = encryptedConn;
        }
      } catch (err) {
        log20.error("Failed to upgrade inbound connection", err);
        throw err;
      }
      if (await this.components.connectionGater.denyInboundUpgradedConnection(remotePeer, {
        ...protectedConn,
        ...encryptedConn
      })) {
        throw (0, import_err_code18.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
      }
      if (metrics != null) {
        metrics.updatePlaceholder(proxyPeer, remotePeer);
        setPeer(remotePeer);
      }
      log20("Successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        muxerFactory,
        remotePeer
      });
    } finally {
      this.components.connectionManager.afterUpgradeInbound();
      timeoutController.clear();
    }
  }
  async upgradeOutbound(maConn, opts) {
    const idStr = maConn.remoteAddr.getPeerId();
    if (idStr == null) {
      throw (0, import_err_code18.default)(new Error("outbound connection must have a peer id"), codes.ERR_INVALID_MULTIADDR);
    }
    const remotePeerId = peerIdFromString(idStr);
    if (await this.components.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {
      throw (0, import_err_code18.default)(new Error("The multiaddr connection is blocked by connectionGater.denyOutboundConnection"), codes.ERR_CONNECTION_INTERCEPTED);
    }
    let encryptedConn;
    let remotePeer;
    let upgradedConn;
    let cryptoProtocol;
    let muxerFactory;
    let setPeer;
    let proxyPeer;
    const metrics = this.components.metrics;
    if (metrics != null) {
      ({ setTarget: setPeer, proxy: proxyPeer } = (0, import_mutable_proxy.default)());
      const idString = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
      setPeer({ toB58String: () => idString });
      metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
    }
    log20("Starting the outbound connection upgrade");
    let protectedConn = maConn;
    if (opts?.skipProtection !== true) {
      const protector = this.components.connectionProtector;
      if (protector != null) {
        protectedConn = await protector.protect(maConn);
      }
    }
    try {
      encryptedConn = protectedConn;
      if (opts?.skipEncryption !== true) {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptOutbound(protectedConn, remotePeerId));
        if (await this.components.connectionGater.denyOutboundEncryptedConnection(remotePeer, {
          ...protectedConn,
          ...encryptedConn
        })) {
          throw (0, import_err_code18.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
        }
      } else {
        cryptoProtocol = "native";
        remotePeer = remotePeerId;
      }
      upgradedConn = encryptedConn;
      if (opts?.muxerFactory != null) {
        muxerFactory = opts.muxerFactory;
      } else if (this.muxers.size > 0) {
        const multiplexed = await this._multiplexOutbound({
          ...protectedConn,
          ...encryptedConn
        }, this.muxers);
        muxerFactory = multiplexed.muxerFactory;
        upgradedConn = multiplexed.stream;
      }
    } catch (err) {
      log20.error("Failed to upgrade outbound connection", err);
      await maConn.close(err);
      throw err;
    }
    if (await this.components.connectionGater.denyOutboundUpgradedConnection(remotePeer, {
      ...protectedConn,
      ...encryptedConn
    })) {
      throw (0, import_err_code18.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), codes.ERR_CONNECTION_INTERCEPTED);
    }
    if (metrics != null) {
      metrics.updatePlaceholder(proxyPeer, remotePeer);
      setPeer(remotePeer);
    }
    log20("Successfully upgraded outbound connection");
    return this._createConnection({
      cryptoProtocol,
      direction: "outbound",
      maConn,
      upgradedConn,
      muxerFactory,
      remotePeer
    });
  }
  _createConnection(opts) {
    const { cryptoProtocol, direction, maConn, upgradedConn, remotePeer, muxerFactory } = opts;
    let muxer;
    let newStream;
    let connection;
    if (muxerFactory != null) {
      muxer = muxerFactory.createStreamMuxer({
        direction,
        onIncomingStream: (muxedStream) => {
          if (connection == null) {
            return;
          }
          void Promise.resolve().then(async () => {
            const protocols = this.components.registrar.getProtocols();
            const { stream, protocol } = await handle(muxedStream, protocols);
            log20("%s: incoming stream opened on %s", direction, protocol);
            const metrics = this.components.metrics;
            if (metrics != null) {
              metrics.trackStream({ stream, remotePeer, protocol });
            }
            if (connection == null) {
              return;
            }
            const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar);
            const streamCount = countStreams(protocol, "inbound", connection);
            if (streamCount === incomingLimit) {
              muxedStream.abort((0, import_err_code18.default)(new Error(`Too many inbound protocol streams for protocol "${protocol}" - limit ${incomingLimit}`), codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS));
              return;
            }
            muxedStream.source = stream.source;
            muxedStream.sink = stream.sink;
            muxedStream.stat.protocol = protocol;
            this.components.peerStore.protoBook.add(remotePeer, [protocol]).catch((err) => log20.error(err));
            connection.addStream(muxedStream);
            this._onStream({ connection, stream: muxedStream, protocol });
          }).catch((err) => {
            log20.error(err);
            if (muxedStream.stat.timeline.close == null) {
              muxedStream.close();
            }
          });
        },
        onStreamEnd: (muxedStream) => {
          connection?.removeStream(muxedStream.id);
        }
      });
      newStream = async (protocols, options = {}) => {
        if (muxer == null) {
          throw (0, import_err_code18.default)(new Error("Stream is not multiplexed"), codes.ERR_MUXER_UNAVAILABLE);
        }
        log20("%s: starting new stream on %s", direction, protocols);
        const muxedStream = await muxer.newStream();
        const metrics = this.components.metrics;
        let controller;
        try {
          if (options.signal == null) {
            log20("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout", protocols);
            controller = new import_timeout_abort_controller4.TimeoutController(3e4);
            options.signal = controller.signal;
            try {
              (0, import_events12.setMaxListeners)?.(Infinity, controller.signal);
            } catch {
            }
          }
          const { stream, protocol } = await select(muxedStream, protocols, options);
          if (metrics != null) {
            metrics.trackStream({ stream, remotePeer, protocol });
          }
          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar);
          const streamCount = countStreams(protocol, "outbound", connection);
          if (streamCount === outgoingLimit) {
            const err = (0, import_err_code18.default)(new Error(`Too many outbound protocol streams for protocol "${protocol}" - limit ${outgoingLimit}`), codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);
            muxedStream.abort(err);
            throw err;
          }
          this.components.peerStore.protoBook.add(remotePeer, [protocol]).catch((err) => log20.error(err));
          muxedStream.source = stream.source;
          muxedStream.sink = stream.sink;
          muxedStream.stat.protocol = protocol;
          return muxedStream;
        } catch (err) {
          log20.error("could not create new stream", err);
          if (muxedStream.stat.timeline.close == null) {
            muxedStream.close();
          }
          if (err.code != null) {
            throw err;
          }
          throw (0, import_err_code18.default)(err, codes.ERR_UNSUPPORTED_PROTOCOL);
        } finally {
          if (controller != null) {
            controller.clear();
          }
        }
      };
      pipe(upgradedConn, muxer, upgradedConn).catch(log20.error);
    }
    const _timeline = maConn.timeline;
    maConn.timeline = new Proxy(_timeline, {
      set: (...args) => {
        if (connection != null && args[1] === "close" && args[2] != null && _timeline.close == null) {
          (async () => {
            try {
              if (connection.stat.status === "OPEN") {
                await connection.close();
              }
            } catch (err) {
              log20.error(err);
            } finally {
              this.dispatchEvent(new CustomEvent("connectionEnd", {
                detail: connection
              }));
            }
          })().catch((err) => {
            log20.error(err);
          });
        }
        return Reflect.set(...args);
      }
    });
    maConn.timeline.upgraded = Date.now();
    const errConnectionNotMultiplexed = () => {
      throw (0, import_err_code18.default)(new Error("connection is not multiplexed"), codes.ERR_CONNECTION_NOT_MULTIPLEXED);
    };
    connection = createConnection({
      remoteAddr: maConn.remoteAddr,
      remotePeer,
      stat: {
        status: "OPEN",
        direction,
        timeline: maConn.timeline,
        multiplexer: muxer?.protocol,
        encryption: cryptoProtocol
      },
      newStream: newStream ?? errConnectionNotMultiplexed,
      getStreams: () => muxer != null ? muxer.streams : errConnectionNotMultiplexed(),
      close: async () => {
        await maConn.close();
        if (muxer != null) {
          muxer.close();
        }
      }
    });
    this.dispatchEvent(new CustomEvent("connection", {
      detail: connection
    }));
    return connection;
  }
  _onStream(opts) {
    const { connection, stream, protocol } = opts;
    const { handler } = this.components.registrar.getHandler(protocol);
    handler({ connection, stream });
  }
  async _encryptInbound(connection) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log20("handling inbound crypto protocol selection", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      log20("encrypting inbound connection...");
      return {
        ...await encrypter.secureInbound(this.components.peerId, stream),
        protocol
      };
    } catch (err) {
      throw (0, import_err_code18.default)(err, codes.ERR_ENCRYPTION_FAILED);
    }
  }
  async _encryptOutbound(connection, remotePeerId) {
    const protocols = Array.from(this.connectionEncryption.keys());
    log20("selecting outbound crypto protocol", protocols);
    try {
      const { stream, protocol } = await select(connection, protocols, {
        writeBytes: true
      });
      const encrypter = this.connectionEncryption.get(protocol);
      if (encrypter == null) {
        throw new Error(`no crypto module found for ${protocol}`);
      }
      log20("encrypting outbound connection to %p", remotePeerId);
      return {
        ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),
        protocol
      };
    } catch (err) {
      throw (0, import_err_code18.default)(err, codes.ERR_ENCRYPTION_FAILED);
    }
  }
  async _multiplexOutbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log20("outbound selecting muxer %s", protocols);
    try {
      const { stream, protocol } = await select(connection, protocols, {
        writeBytes: true
      });
      log20("%s selected as muxer protocol", protocol);
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      log20.error("error multiplexing outbound stream", err);
      throw (0, import_err_code18.default)(err, codes.ERR_MUXER_UNAVAILABLE);
    }
  }
  async _multiplexInbound(connection, muxers) {
    const protocols = Array.from(muxers.keys());
    log20("inbound handling muxers %s", protocols);
    try {
      const { stream, protocol } = await handle(connection, protocols, {
        writeBytes: true
      });
      const muxerFactory = muxers.get(protocol);
      return { stream, muxerFactory };
    } catch (err) {
      log20.error("error multiplexing inbound stream", err);
      throw (0, import_err_code18.default)(err, codes.ERR_MUXER_UNAVAILABLE);
    }
  }
};

// node_modules/libp2p/dist/src/identify/index.js
var import_err_code20 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/identify/pb/message.js
var Identify;
(function(Identify2) {
  let _codec;
  Identify2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(26);
            w.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader6.string();
              break;
            case 6:
              obj.agentVersion = reader6.string();
              break;
            case 1:
              obj.publicKey = reader6.bytes();
              break;
            case 2:
              obj.listenAddrs.push(reader6.bytes());
              break;
            case 4:
              obj.observedAddr = reader6.bytes();
              break;
            case 3:
              obj.protocols.push(reader6.string());
              break;
            case 8:
              obj.signedPeerRecord = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify2.encode = (obj) => {
    return encodeMessage(obj, Identify2.codec());
  };
  Identify2.decode = (buf) => {
    return decodeMessage(buf, Identify2.codec());
  };
})(Identify || (Identify = {}));

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var import_err_code19 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array4(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe4(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array4(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec5(name2, prefix, encode3, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: {
      decode: decode2
    }
  };
}
var string4 = createCodec5("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii4 = createCodec5("ascii", "a", (buf) => {
  let string6 = "a";
  for (let i = 0; i < buf.length; i++) {
    string6 += String.fromCharCode(buf[i]);
  }
  return string6;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe4(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
var BASES4 = {
  utf8: string4,
  "utf-8": string4,
  hex: bases.base16,
  latin1: ascii4,
  ascii: ascii4,
  binary: ascii4,
  ...bases
};
var bases_default4 = BASES4;

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/from-string.js
function fromString5(string6, encoding = "utf8") {
  const base = bases_default4[encoding];
  if (base == null) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array4(globalThis.Buffer.from(string6, "utf-8"));
  }
  return base.decoder.decode(`${base.prefix}${string6}`);
}

// node_modules/@libp2p/peer-record/node_modules/uint8arrays/dist/src/equals.js
function equals(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/peer-record/dist/src/errors.js
var codes2 = {
  ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
};

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/utils.js
var import_reader2 = __toESM(require_reader(), 1);
var import_reader_buffer2 = __toESM(require_reader_buffer(), 1);
var import_writer2 = __toESM(require_writer(), 1);
var import_writer_buffer2 = __toESM(require_writer_buffer(), 1);
var import_minimal2 = __toESM(require_minimal(), 1);
function configure2() {
  import_minimal2.default._configure();
  import_reader2.default._configure(import_reader_buffer2.default);
  import_writer2.default._configure(import_writer_buffer2.default);
}
configure2();
var methods2 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader2(obj) {
  for (const method of methods2) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader3(buf) {
  return patchReader2(new import_reader2.default(buf));
}
function patchWriter2(obj) {
  for (const method of methods2) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer2() {
  return patchWriter2(import_writer2.default.create());
}

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage2(buf, codec) {
  const r = reader3(buf instanceof Uint8Array ? buf : buf.subarray());
  return codec.decode(r);
}

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage2(message5, codec) {
  const w = writer2();
  codec.encode(message5, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES2;
(function(CODEC_TYPES5) {
  CODEC_TYPES5[CODEC_TYPES5["VARINT"] = 0] = "VARINT";
  CODEC_TYPES5[CODEC_TYPES5["BIT64"] = 1] = "BIT64";
  CODEC_TYPES5[CODEC_TYPES5["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES5[CODEC_TYPES5["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES5[CODEC_TYPES5["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES5[CODEC_TYPES5["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES2 || (CODEC_TYPES2 = {}));
function createCodec6(name2, type, encode3, decode2) {
  return {
    name: name2,
    type,
    encode: encode3,
    decode: decode2
  };
}

// node_modules/@libp2p/peer-record/node_modules/protons-runtime/dist/src/codecs/message.js
function message2(encode3, decode2) {
  return createCodec6("message", CODEC_TYPES2.LENGTH_DELIMITED, encode3, decode2);
}

// node_modules/@libp2p/peer-record/dist/src/envelope/envelope.js
var Envelope;
(function(Envelope2) {
  let _codec;
  Envelope2.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.publicKey != null && obj.publicKey.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (opts.writeDefaults === true || obj.payloadType != null && obj.payloadType.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.payloadType);
        }
        if (opts.writeDefaults === true || obj.payload != null && obj.payload.byteLength > 0) {
          w.uint32(26);
          w.bytes(obj.payload);
        }
        if (opts.writeDefaults === true || obj.signature != null && obj.signature.byteLength > 0) {
          w.uint32(42);
          w.bytes(obj.signature);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          publicKey: new Uint8Array(0),
          payloadType: new Uint8Array(0),
          payload: new Uint8Array(0),
          signature: new Uint8Array(0)
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.publicKey = reader6.bytes();
              break;
            case 2:
              obj.payloadType = reader6.bytes();
              break;
            case 3:
              obj.payload = reader6.bytes();
              break;
            case 5:
              obj.signature = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Envelope2.encode = (obj) => {
    return encodeMessage2(obj, Envelope2.codec());
  };
  Envelope2.decode = (buf) => {
    return decodeMessage2(buf, Envelope2.codec());
  };
})(Envelope || (Envelope = {}));

// node_modules/@libp2p/peer-record/dist/src/envelope/index.js
var _a;
var RecordEnvelope = class {
  constructor(init) {
    const { peerId, payloadType, payload, signature } = init;
    this.peerId = peerId;
    this.payloadType = payloadType;
    this.payload = payload;
    this.signature = signature;
  }
  marshal() {
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    if (this.marshaled == null) {
      this.marshaled = Envelope.encode({
        publicKey: this.peerId.publicKey,
        payloadType: this.payloadType,
        payload: this.payload.subarray(),
        signature: this.signature
      });
    }
    return this.marshaled;
  }
  equals(other) {
    return equals(this.marshal(), other.marshal());
  }
  async validate(domain) {
    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
    if (this.peerId.publicKey == null) {
      throw new Error("Missing public key");
    }
    const key = unmarshalPublicKey(this.peerId.publicKey);
    return await key.verify(signData.subarray(), this.signature);
  }
};
_a = RecordEnvelope;
RecordEnvelope.createFromProtobuf = async (data) => {
  const envelopeData = Envelope.decode(data);
  const peerId = await peerIdFromKeys(envelopeData.publicKey);
  return new RecordEnvelope({
    peerId,
    payloadType: envelopeData.payloadType,
    payload: envelopeData.payload,
    signature: envelopeData.signature
  });
};
RecordEnvelope.seal = async (record, peerId) => {
  if (peerId.privateKey == null) {
    throw new Error("Missing private key");
  }
  const domain = record.domain;
  const payloadType = record.codec;
  const payload = record.marshal();
  const signData = formatSignaturePayload(domain, payloadType, payload);
  const key = await unmarshalPrivateKey(peerId.privateKey);
  const signature = await key.sign(signData.subarray());
  return new RecordEnvelope({
    peerId,
    payloadType,
    payload,
    signature
  });
};
RecordEnvelope.openAndCertify = async (data, domain) => {
  const envelope = await RecordEnvelope.createFromProtobuf(data);
  const valid = await envelope.validate(domain);
  if (!valid) {
    throw (0, import_err_code19.default)(new Error("envelope signature is not valid for the given domain"), codes2.ERR_SIGNATURE_NOT_VALID);
  }
  return envelope;
};
var formatSignaturePayload = (domain, payloadType, payload) => {
  const domainUint8Array = fromString5(domain);
  const domainLength = unsigned.encode(domainUint8Array.byteLength);
  const payloadTypeLength = unsigned.encode(payloadType.length);
  const payloadLength = unsigned.encode(payload.length);
  return new Uint8ArrayList(domainLength, domainUint8Array, payloadTypeLength, payloadType, payloadLength, payload);
};

// node_modules/@libp2p/utils/dist/src/array-equals.js
function arrayEquals(a, b) {
  const sort2 = (a2, b2) => a2.toString().localeCompare(b2.toString());
  if (a.length !== b.length) {
    return false;
  }
  b.sort(sort2);
  return a.sort(sort2).every((item, index) => b[index].equals(item));
}

// node_modules/@libp2p/peer-record/dist/src/peer-record/peer-record.js
var PeerRecord;
(function(PeerRecord3) {
  let AddressInfo;
  (function(AddressInfo2) {
    let _codec2;
    AddressInfo2.codec = () => {
      if (_codec2 == null) {
        _codec2 = message2((obj, w, opts = {}) => {
          if (opts.lengthDelimited !== false) {
            w.fork();
          }
          if (opts.writeDefaults === true || obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
            w.uint32(10);
            w.bytes(obj.multiaddr);
          }
          if (opts.lengthDelimited !== false) {
            w.ldelim();
          }
        }, (reader6, length) => {
          const obj = {
            multiaddr: new Uint8Array(0)
          };
          const end = length == null ? reader6.len : reader6.pos + length;
          while (reader6.pos < end) {
            const tag = reader6.uint32();
            switch (tag >>> 3) {
              case 1:
                obj.multiaddr = reader6.bytes();
                break;
              default:
                reader6.skipType(tag & 7);
                break;
            }
          }
          return obj;
        });
      }
      return _codec2;
    };
    AddressInfo2.encode = (obj) => {
      return encodeMessage2(obj, AddressInfo2.codec());
    };
    AddressInfo2.decode = (buf) => {
      return decodeMessage2(buf, AddressInfo2.codec());
    };
  })(AddressInfo = PeerRecord3.AddressInfo || (PeerRecord3.AddressInfo = {}));
  let _codec;
  PeerRecord3.codec = () => {
    if (_codec == null) {
      _codec = message2((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.peerId != null && obj.peerId.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.peerId);
        }
        if (opts.writeDefaults === true || obj.seq !== 0n) {
          w.uint32(16);
          w.uint64(obj.seq);
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(26);
            PeerRecord3.AddressInfo.codec().encode(value, w, {
              writeDefaults: true
            });
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          peerId: new Uint8Array(0),
          seq: 0n,
          addresses: []
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.peerId = reader6.bytes();
              break;
            case 2:
              obj.seq = reader6.uint64();
              break;
            case 3:
              obj.addresses.push(PeerRecord3.AddressInfo.codec().decode(reader6, reader6.uint32()));
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerRecord3.encode = (obj) => {
    return encodeMessage2(obj, PeerRecord3.codec());
  };
  PeerRecord3.decode = (buf) => {
    return decodeMessage2(buf, PeerRecord3.codec());
  };
})(PeerRecord || (PeerRecord = {}));

// node_modules/@libp2p/peer-record/dist/src/peer-record/consts.js
var ENVELOPE_DOMAIN_PEER_RECORD = "libp2p-peer-record";
var ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);

// node_modules/@libp2p/peer-record/dist/src/peer-record/index.js
var PeerRecord2 = class {
  constructor(init) {
    this.domain = PeerRecord2.DOMAIN;
    this.codec = PeerRecord2.CODEC;
    const { peerId, multiaddrs, seqNumber } = init;
    this.peerId = peerId;
    this.multiaddrs = multiaddrs ?? [];
    this.seqNumber = seqNumber ?? BigInt(Date.now());
  }
  marshal() {
    if (this.marshaled == null) {
      this.marshaled = PeerRecord.encode({
        peerId: this.peerId.toBytes(),
        seq: BigInt(this.seqNumber),
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
    }
    return this.marshaled;
  }
  equals(other) {
    if (!(other instanceof PeerRecord2)) {
      return false;
    }
    if (!this.peerId.equals(other.peerId)) {
      return false;
    }
    if (this.seqNumber !== other.seqNumber) {
      return false;
    }
    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
      return false;
    }
    return true;
  }
};
PeerRecord2.createFromProtobuf = (buf) => {
  const peerRecord = PeerRecord.decode(buf);
  const peerId = peerIdFromBytes(peerRecord.peerId);
  const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr));
  const seqNumber = peerRecord.seq;
  return new PeerRecord2({ peerId, multiaddrs, seqNumber });
};
PeerRecord2.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
PeerRecord2.CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;

// node_modules/libp2p/dist/src/version.js
var version = "0.0.0";
var name = "libp2p";

// node_modules/libp2p/dist/src/identify/consts.js
var AGENT_VERSION = `js-libp2p/${version}`;
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";

// node_modules/libp2p/dist/src/identify/index.js
var import_timeout_abort_controller5 = __toESM(require_timeout_abort_controller(), 1);
var import_events13 = __toESM(require_events(), 1);
var log21 = logger("libp2p:identify");
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var IdentifyService = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.init = init;
    this.identifyProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
    this.identifyPushProtocolStr = `/${init.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
    this.host = {
      protocolVersion: `${init.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      ...init.host
    };
    this.components.connectionManager.addEventListener("peer:connect", (evt) => {
      const connection = evt.detail;
      this.identify(connection).catch(log21.error);
    });
    this.components.peerStore.addEventListener("change:multiaddrs", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.peerId.equals(peerId)) {
        void this.pushToPeerStore().catch((err) => log21.error(err));
      }
    });
    this.components.peerStore.addEventListener("change:protocols", (evt) => {
      const { peerId } = evt.detail;
      if (this.components.peerId.equals(peerId)) {
        void this.pushToPeerStore().catch((err) => log21.error(err));
      }
    });
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.components.peerStore.metadataBook.setValue(this.components.peerId, "AgentVersion", fromString2(this.host.agentVersion));
    await this.components.peerStore.metadataBook.setValue(this.components.peerId, "ProtocolVersion", fromString2(this.host.protocolVersion));
    await this.components.registrar.handle(this.identifyProtocolStr, (data) => {
      void this._handleIdentify(data).catch((err) => {
        log21.error(err);
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    await this.components.registrar.handle(this.identifyPushProtocolStr, (data) => {
      void this._handlePush(data).catch((err) => {
        log21.error(err);
      });
    }, {
      maxInboundStreams: this.init.maxPushIncomingStreams,
      maxOutboundStreams: this.init.maxPushOutgoingStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.identifyProtocolStr);
    await this.components.registrar.unhandle(this.identifyPushProtocolStr);
    this.started = false;
  }
  async push(connections) {
    const signedPeerRecord = await this.components.peerStore.addressBook.getRawEnvelope(this.components.peerId);
    const listenAddrs = this.components.addressManager.getAddresses().map((ma) => ma.bytes);
    const protocols = await this.components.peerStore.protoBook.get(this.components.peerId);
    const pushes = connections.map(async (connection) => {
      let stream;
      const timeoutController = new import_timeout_abort_controller5.TimeoutController(this.init.timeout);
      try {
        (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
      try {
        stream = await connection.newStream([this.identifyPushProtocolStr], {
          signal: timeoutController.signal
        });
        const source = abortableDuplex(stream, timeoutController.signal);
        await source.sink(pipe([Identify.encode({
          listenAddrs,
          signedPeerRecord,
          protocols
        })], encode()));
      } catch (err) {
        log21.error("could not push identify update to peer", err);
      } finally {
        if (stream != null) {
          stream.close();
        }
        timeoutController.clear();
      }
    });
    await Promise.all(pushes);
  }
  async pushToPeerStore() {
    if (!this.isStarted()) {
      return;
    }
    const connections = [];
    for (const conn of this.components.connectionManager.getConnections()) {
      const peerId = conn.remotePeer;
      const peer = await this.components.peerStore.get(peerId);
      if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
        continue;
      }
      connections.push(conn);
    }
    await this.push(connections);
  }
  async _identify(connection, options = {}) {
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller5.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.identifyProtocolStr], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const data = await pipe([], source, decode({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => await first(source2));
      if (data == null) {
        throw (0, import_err_code20.default)(new Error("No data could be retrieved"), codes.ERR_CONNECTION_ENDED);
      }
      try {
        return Identify.decode(data);
      } catch (err) {
        throw (0, import_err_code20.default)(err, codes.ERR_INVALID_MESSAGE);
      }
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
  async identify(connection, options = {}) {
    const message5 = await this._identify(connection, options);
    const { publicKey, listenAddrs, protocols, observedAddr, signedPeerRecord, agentVersion, protocolVersion } = message5;
    if (publicKey == null) {
      throw (0, import_err_code20.default)(new Error("public key was missing from identify message"), codes.ERR_MISSING_PUBLIC_KEY);
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw (0, import_err_code20.default)(new Error("identified peer does not match the expected peer"), codes.ERR_INVALID_PEER);
    }
    if (this.components.peerId.equals(id)) {
      throw (0, import_err_code20.default)(new Error("identified peer is our own peer id?"), codes.ERR_INVALID_PEER);
    }
    const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
    if (signedPeerRecord != null) {
      log21("received signed peer record from %p", id);
      try {
        const envelope = await RecordEnvelope.openAndCertify(signedPeerRecord, PeerRecord2.DOMAIN);
        if (!envelope.peerId.equals(id)) {
          throw (0, import_err_code20.default)(new Error("identified peer does not match the expected peer"), codes.ERR_INVALID_PEER);
        }
        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {
          await this.components.peerStore.protoBook.set(id, protocols);
          if (agentVersion != null) {
            await this.components.peerStore.metadataBook.setValue(id, "AgentVersion", fromString2(agentVersion));
          }
          if (protocolVersion != null) {
            await this.components.peerStore.metadataBook.setValue(id, "ProtocolVersion", fromString2(protocolVersion));
          }
          log21("identify completed for peer %p and protocols %o", id, protocols);
          return;
        }
      } catch (err) {
        log21("received invalid envelope, discard it and fallback to listenAddrs is available", err);
      }
    } else {
      log21("no signed peer record received from %p", id);
    }
    log21("falling back to legacy addresses from %p", id);
    try {
      await this.components.peerStore.addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err) {
      log21.error("received invalid addrs", err);
    }
    await this.components.peerStore.protoBook.set(id, protocols);
    if (agentVersion != null) {
      await this.components.peerStore.metadataBook.setValue(id, "AgentVersion", fromString2(agentVersion));
    }
    if (protocolVersion != null) {
      await this.components.peerStore.metadataBook.setValue(id, "ProtocolVersion", fromString2(protocolVersion));
    }
    log21("identify completed for peer %p and protocols %o", id, protocols);
    log21("received observed address of %s", cleanObservedAddr?.toString());
  }
  async _handleIdentify(data) {
    const { connection, stream } = data;
    const timeoutController = new import_timeout_abort_controller5.TimeoutController(this.init.timeout);
    try {
      (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    try {
      const publicKey = this.components.peerId.publicKey ?? new Uint8Array(0);
      const peerData = await this.components.peerStore.get(this.components.peerId);
      const multiaddrs = this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord2({
          peerId: this.components.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);
        await this.components.peerStore.addressBook.consumePeerRecord(envelope);
        signedPeerRecord = envelope.marshal().subarray();
      }
      const message5 = Identify.encode({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr: connection.remoteAddr.bytes,
        protocols: peerData.protocols
      });
      const source = abortableDuplex(stream, timeoutController.signal);
      const msgWithLenPrefix = pipe([message5], encode());
      await source.sink(msgWithLenPrefix);
    } catch (err) {
      log21.error("could not respond to identify request", err);
    } finally {
      stream.close();
      timeoutController.clear();
    }
  }
  async _handlePush(data) {
    const { connection, stream } = data;
    const timeoutController = new import_timeout_abort_controller5.TimeoutController(this.init.timeout);
    try {
      (0, import_events13.setMaxListeners)?.(Infinity, timeoutController.signal);
    } catch {
    }
    let message5;
    try {
      const source = abortableDuplex(stream, timeoutController.signal);
      const data2 = await pipe([], source, decode({
        maxDataLength: this.init.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }), async (source2) => await first(source2));
      if (data2 != null) {
        message5 = Identify.decode(data2);
      }
    } catch (err) {
      return log21.error("received invalid message", err);
    } finally {
      stream.close();
      timeoutController.clear();
    }
    if (message5 == null) {
      return log21.error("received invalid message");
    }
    const id = connection.remotePeer;
    if (this.components.peerId.equals(id)) {
      log21("received push from ourselves?");
      return;
    }
    log21("received push from %p", id);
    if (message5.signedPeerRecord != null) {
      log21("received signedPeerRecord in push");
      try {
        const envelope = await RecordEnvelope.openAndCertify(message5.signedPeerRecord, PeerRecord2.DOMAIN);
        if (await this.components.peerStore.addressBook.consumePeerRecord(envelope)) {
          log21("consumed signedPeerRecord sent in push");
          await this.components.peerStore.protoBook.set(id, message5.protocols);
          return;
        } else {
          log21("failed to consume signedPeerRecord sent in push");
        }
      } catch (err) {
        log21("received invalid envelope, discard it and fallback to listenAddrs is available", err);
      }
    } else {
      log21("did not receive signedPeerRecord in push");
    }
    try {
      await this.components.peerStore.addressBook.set(id, message5.listenAddrs.map((addr) => multiaddr(addr)));
    } catch (err) {
      log21.error("received invalid addrs", err);
    }
    try {
      await this.components.peerStore.protoBook.set(id, message5.protocols);
    } catch (err) {
      log21.error("received invalid protocols", err);
    }
    log21("handled push from %p", id);
  }
  static getCleanMultiaddr(addr) {
    if (addr != null && addr.length > 0) {
      try {
        return multiaddr(addr);
      } catch {
      }
    }
  }
};

// node_modules/libp2p/dist/src/fetch/index.js
var import_err_code21 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/fetch/pb/proto.js
var FetchRequest;
(function(FetchRequest2) {
  let _codec;
  FetchRequest2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.identifier !== "") {
          w.uint32(10);
          w.string(obj.identifier);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          identifier: ""
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.identifier = reader6.string();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchRequest2.encode = (obj) => {
    return encodeMessage(obj, FetchRequest2.codec());
  };
  FetchRequest2.decode = (buf) => {
    return decodeMessage(buf, FetchRequest2.codec());
  };
})(FetchRequest || (FetchRequest = {}));
var FetchResponse;
(function(FetchResponse2) {
  let StatusCode;
  (function(StatusCode2) {
    StatusCode2["OK"] = "OK";
    StatusCode2["NOT_FOUND"] = "NOT_FOUND";
    StatusCode2["ERROR"] = "ERROR";
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let __StatusCodeValues;
  (function(__StatusCodeValues2) {
    __StatusCodeValues2[__StatusCodeValues2["OK"] = 0] = "OK";
    __StatusCodeValues2[__StatusCodeValues2["NOT_FOUND"] = 1] = "NOT_FOUND";
    __StatusCodeValues2[__StatusCodeValues2["ERROR"] = 2] = "ERROR";
  })(__StatusCodeValues || (__StatusCodeValues = {}));
  (function(StatusCode2) {
    StatusCode2.codec = () => {
      return enumeration(__StatusCodeValues);
    };
  })(StatusCode = FetchResponse2.StatusCode || (FetchResponse2.StatusCode = {}));
  let _codec;
  FetchResponse2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.status != null && __StatusCodeValues[obj.status] !== 0) {
          w.uint32(8);
          FetchResponse2.StatusCode.codec().encode(obj.status, w);
        }
        if (opts.writeDefaults === true || obj.data != null && obj.data.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          status: StatusCode.OK,
          data: new Uint8Array(0)
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.status = FetchResponse2.StatusCode.codec().decode(reader6);
              break;
            case 2:
              obj.data = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  FetchResponse2.encode = (obj) => {
    return encodeMessage(obj, FetchResponse2.codec());
  };
  FetchResponse2.decode = (buf) => {
    return decodeMessage(buf, FetchResponse2.codec());
  };
})(FetchResponse || (FetchResponse = {}));

// node_modules/libp2p/dist/src/fetch/constants.js
var PROTOCOL_VERSION = "0.0.1";
var PROTOCOL_NAME = "fetch";

// node_modules/libp2p/dist/src/fetch/index.js
var import_timeout_abort_controller6 = __toESM(require_timeout_abort_controller(), 1);
var import_events14 = __toESM(require_events(), 1);
var log22 = logger("libp2p:fetch");
var FetchService = class {
  constructor(components, init) {
    this.started = false;
    this.components = components;
    this.protocol = `/${init.protocolPrefix ?? "libp2p"}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
    this.lookupFunctions = /* @__PURE__ */ new Map();
    this.handleMessage = this.handleMessage.bind(this);
    this.init = init;
  }
  async start() {
    await this.components.registrar.handle(this.protocol, (data) => {
      void this.handleMessage(data).catch((err) => {
        log22.error(err);
      }).finally(() => {
        data.stream.close();
      });
    }, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async fetch(peer, key, options = {}) {
    log22("dialing %s to %p", this.protocol, peer);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller6.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events14.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.protocol], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const result = await pipe([FetchRequest.encode({ identifier: key })], encode(), source, decode(), async function(source2) {
        const buf = await first(source2);
        if (buf == null) {
          throw (0, import_err_code21.default)(new Error("No data received"), codes.ERR_INVALID_MESSAGE);
        }
        const response = FetchResponse.decode(buf);
        switch (response.status) {
          case FetchResponse.StatusCode.OK: {
            return response.data;
          }
          case FetchResponse.StatusCode.NOT_FOUND: {
            return null;
          }
          case FetchResponse.StatusCode.ERROR: {
            const errmsg = new TextDecoder().decode(response.data);
            throw (0, import_err_code21.default)(new Error("Error in fetch protocol response: " + errmsg), codes.ERR_INVALID_PARAMETERS);
          }
          default: {
            throw (0, import_err_code21.default)(new Error("Unknown response status"), codes.ERR_INVALID_MESSAGE);
          }
        }
      });
      return result ?? null;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
  async handleMessage(data) {
    const { stream } = data;
    const self = this;
    await pipe(stream, decode(), async function* (source) {
      const buf = await first(source);
      if (buf == null) {
        throw (0, import_err_code21.default)(new Error("No data received"), codes.ERR_INVALID_MESSAGE);
      }
      const request2 = FetchRequest.decode(buf);
      let response;
      const lookup = self._getLookupFunction(request2.identifier);
      if (lookup != null) {
        const data2 = await lookup(request2.identifier);
        if (data2 != null) {
          response = { status: FetchResponse.StatusCode.OK, data: data2 };
        } else {
          response = { status: FetchResponse.StatusCode.NOT_FOUND, data: new Uint8Array(0) };
        }
      } else {
        const errmsg = new TextEncoder().encode("No lookup function registered for key: " + request2.identifier);
        response = { status: FetchResponse.StatusCode.ERROR, data: errmsg };
      }
      yield FetchResponse.encode(response);
    }, encode(), stream);
  }
  _getLookupFunction(key) {
    for (const prefix of this.lookupFunctions.keys()) {
      if (key.startsWith(prefix)) {
        return this.lookupFunctions.get(prefix);
      }
    }
  }
  registerLookupFunction(prefix, lookup) {
    if (this.lookupFunctions.has(prefix)) {
      throw (0, import_err_code21.default)(new Error("Fetch protocol handler for key prefix '" + prefix + "' already registered"), codes.ERR_KEY_ALREADY_EXISTS);
    }
    this.lookupFunctions.set(prefix, lookup);
  }
  unregisterLookupFunction(prefix, lookup) {
    if (lookup != null) {
      const existingLookup = this.lookupFunctions.get(prefix);
      if (existingLookup !== lookup) {
        return;
      }
    }
    this.lookupFunctions.delete(prefix);
  }
};

// node_modules/libp2p/dist/src/ping/index.js
var import_err_code22 = __toESM(require_err_code(), 1);

// node_modules/libp2p/node_modules/uint8arrays/dist/src/equals.js
function equals2(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/libp2p/dist/src/ping/constants.js
var PING_LENGTH = 32;
var PROTOCOL_VERSION2 = "1.0.0";
var PROTOCOL_NAME2 = "ping";

// node_modules/libp2p/dist/src/ping/index.js
var import_timeout_abort_controller7 = __toESM(require_timeout_abort_controller(), 1);
var import_events15 = __toESM(require_events(), 1);
var log23 = logger("libp2p:ping");
var PingService = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.protocol = `/${init.protocolPrefix}/${PROTOCOL_NAME2}/${PROTOCOL_VERSION2}`;
    this.init = init;
  }
  async start() {
    await this.components.registrar.handle(this.protocol, this.handleMessage, {
      maxInboundStreams: this.init.maxInboundStreams,
      maxOutboundStreams: this.init.maxOutboundStreams
    });
    this.started = true;
  }
  async stop() {
    await this.components.registrar.unhandle(this.protocol);
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  handleMessage(data) {
    const { stream } = data;
    void pipe(stream, stream).catch((err) => {
      log23.error(err);
    });
  }
  async ping(peer, options = {}) {
    log23("dialing %s to %p", this.protocol, peer);
    const start = Date.now();
    const data = randomBytes(PING_LENGTH);
    const connection = await this.components.connectionManager.openConnection(peer, options);
    let timeoutController;
    let signal = options.signal;
    let stream;
    if (signal == null) {
      timeoutController = new import_timeout_abort_controller7.TimeoutController(this.init.timeout);
      signal = timeoutController.signal;
      try {
        (0, import_events15.setMaxListeners)?.(Infinity, timeoutController.signal);
      } catch {
      }
    }
    try {
      stream = await connection.newStream([this.protocol], {
        signal
      });
      const source = abortableDuplex(stream, signal);
      const result = await pipe([data], source, async (source2) => await first(source2));
      const end = Date.now();
      if (result == null || !equals2(data, result.subarray())) {
        throw (0, import_err_code22.default)(new Error("Received wrong ping ack"), codes.ERR_WRONG_PING_ACK);
      }
      return end - start;
    } finally {
      if (timeoutController != null) {
        timeoutController.clear();
      }
      if (stream != null) {
        stream.close();
      }
    }
  }
};

// node_modules/@achingbrain/nat-port-mapper/dist/src/browser.js
async function upnpNat() {
  throw new Error("Not supported in browsers");
}

// node_modules/libp2p/dist/src/nat-manager.js
var import_private_ip2 = __toESM(require_private_ip(), 1);
var import_err_code23 = __toESM(require_err_code(), 1);

// node_modules/is-loopback-addr/dist/src/index.js
function isLoopbackAddr(ip) {
  return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
}

// node_modules/@libp2p/utils/dist/src/multiaddr/is-loopback.js
function isLoopback(ma) {
  const { address } = ma.nodeAddress();
  return isLoopbackAddr(address);
}

// node_modules/libp2p/dist/src/nat-manager.js
var log24 = logger("libp2p:nat");
var DEFAULT_TTL = 7200;
function highPort(min = 1024, max = 65535) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
var NatManager = class {
  constructor(components, init) {
    this.components = components;
    this.started = false;
    this.enabled = init.enabled;
    this.externalAddress = init.externalAddress;
    this.localAddress = init.localAddress;
    this.description = init.description ?? `${name}@${version} ${this.components.peerId.toString()}`;
    this.ttl = init.ttl ?? DEFAULT_TTL;
    this.keepAlive = init.keepAlive ?? true;
    this.gateway = init.gateway;
    if (this.ttl < DEFAULT_TTL) {
      throw (0, import_err_code23.default)(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), codes.ERR_INVALID_PARAMETERS);
    }
  }
  isStarted() {
    return this.started;
  }
  start() {
  }
  afterStart() {
    if (isBrowser || !this.enabled || this.started) {
      return;
    }
    this.started = true;
    void this._start().catch((err) => {
      log24.error(err);
    });
  }
  async _start() {
    const addrs = this.components.transportManager.getAddrs();
    for (const addr of addrs) {
      const { family, host, port, transport } = addr.toOptions();
      if (!addr.isThinWaistAddress() || transport !== "tcp") {
        continue;
      }
      if (isLoopback(addr)) {
        continue;
      }
      if (family !== 4) {
        continue;
      }
      const client = await this._getClient();
      const publicIp = this.externalAddress ?? await client.externalIp();
      if ((0, import_private_ip2.default)(publicIp)) {
        throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
      }
      const publicPort = highPort();
      log24(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
      await client.map({
        publicPort,
        localPort: port,
        localAddress: this.localAddress,
        protocol: transport.toUpperCase() === "TCP" ? "TCP" : "UDP"
      });
      this.components.addressManager.addObservedAddr(fromNodeAddress({
        family: 4,
        address: publicIp,
        port: publicPort
      }, transport));
    }
  }
  async _getClient() {
    if (this.client != null) {
      return this.client;
    }
    this.client = await upnpNat({
      description: this.description,
      ttl: this.ttl,
      keepAlive: this.keepAlive,
      gateway: this.gateway
    });
    return this.client;
  }
  async stop() {
    if (isBrowser || this.client == null) {
      return;
    }
    try {
      await this.client.close();
      this.client = void 0;
    } catch (err) {
      log24.error(err);
    }
  }
};

// node_modules/libp2p/dist/src/peer-record-updater.js
var log25 = logger("libp2p:peer-record-updater");
var PeerRecordUpdater = class {
  constructor(components) {
    this.components = components;
    this.started = false;
    this.update = this.update.bind(this);
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
    this.components.transportManager.addEventListener("listener:listening", this.update);
    this.components.transportManager.addEventListener("listener:close", this.update);
    this.components.addressManager.addEventListener("change:addresses", this.update);
  }
  async stop() {
    this.started = false;
    this.components.transportManager.removeEventListener("listener:listening", this.update);
    this.components.transportManager.removeEventListener("listener:close", this.update);
    this.components.addressManager.removeEventListener("change:addresses", this.update);
  }
  update() {
    Promise.resolve().then(async () => {
      const peerRecord = new PeerRecord2({
        peerId: this.components.peerId,
        multiaddrs: this.components.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code))
      });
      const envelope = await RecordEnvelope.seal(peerRecord, this.components.peerId);
      await this.components.peerStore.addressBook.consumePeerRecord(envelope);
    }).catch((err) => {
      log25.error("Could not update self peer record: %o", err);
    });
  }
};

// node_modules/libp2p/dist/src/dht/dht-peer-routing.js
var import_err_code24 = __toESM(require_err_code(), 1);
var DHTPeerRouting = class {
  constructor(dht) {
    this.dht = dht;
  }
  async findPeer(peerId, options = {}) {
    for await (const event of this.dht.findPeer(peerId, options)) {
      if (event.name === "FINAL_PEER") {
        return event.peer;
      }
    }
    throw (0, import_err_code24.default)(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
  }
  async *getClosestPeers(key, options = {}) {
    for await (const event of this.dht.getClosestPeers(key, options)) {
      if (event.name === "FINAL_PEER") {
        yield event.peer;
      }
    }
  }
};

// node_modules/@libp2p/peer-store/dist/src/address-book.js
var import_err_code25 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/peer-store/dist/src/errors.js
var codes3 = {
  ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
  ERR_NOT_FOUND: "ERR_NOT_FOUND"
};

// node_modules/@libp2p/peer-store/dist/src/address-book.js
var import_it_all5 = __toESM(require_it_all2(), 1);
var import_it_filter5 = __toESM(require_it_filter2(), 1);
var import_it_map2 = __toESM(require_it_map(), 1);
var import_it_foreach2 = __toESM(require_it_foreach(), 1);
var log26 = logger("libp2p:peer-store:address-book");
var EVENT_NAME = "change:multiaddrs";
async function allowAll() {
  return true;
}
var PeerStoreAddressBook = class {
  constructor(dispatchEvent, store, addressFilter) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
    this.addressFilter = addressFilter ?? allowAll;
  }
  async consumePeerRecord(envelope) {
    log26.trace("consumePeerRecord await write lock");
    const release = await this.store.lock.writeLock();
    log26.trace("consumePeerRecord got write lock");
    let peerId;
    let peer;
    let updatedPeer;
    try {
      let peerRecord;
      try {
        peerRecord = PeerRecord2.createFromProtobuf(envelope.payload);
      } catch (err) {
        log26.error("invalid peer record received");
        return false;
      }
      peerId = peerRecord.peerId;
      const multiaddrs = peerRecord.multiaddrs;
      if (!peerId.equals(envelope.peerId)) {
        log26("signing key does not match PeerId in the PeerRecord");
        return false;
      }
      if (multiaddrs == null || multiaddrs.length === 0) {
        return false;
      }
      if (await this.store.has(peerId)) {
        peer = await this.store.load(peerId);
        if (peer.peerRecordEnvelope != null) {
          const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope);
          const storedRecord = PeerRecord2.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            log26("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            return false;
          }
        }
      }
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter, true);
      updatedPeer = await this.store.patchOrCreate(peerId, {
        addresses,
        peerRecordEnvelope: envelope.marshal().subarray()
      });
      log26("stored provided peer record for %p", peerRecord.peerId);
    } finally {
      log26.trace("consumePeerRecord release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    return true;
  }
  async getRawEnvelope(peerId) {
    log26.trace("getRawEnvelope await read lock");
    const release = await this.store.lock.readLock();
    log26.trace("getRawEnvelope got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.peerRecordEnvelope;
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
    } finally {
      log26.trace("getRawEnvelope release read lock");
      release();
    }
  }
  async getPeerRecord(peerId) {
    const raw = await this.getRawEnvelope(peerId);
    if (raw == null) {
      return void 0;
    }
    return await RecordEnvelope.createFromProtobuf(raw);
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log26.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log26.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.addresses;
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
    } finally {
      log26.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log26.error("multiaddrs must be an array of Multiaddrs");
      throw (0, import_err_code25.default)(new Error("multiaddrs must be an array of Multiaddrs"), codes3.ERR_INVALID_PARAMETERS);
    }
    log26.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log26.trace("set got write lock");
    let hasPeer = false;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length && addresses.length === peer.addresses.length) {
          return;
        }
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, { addresses });
      log26("set multiaddrs for %p", peerId);
    } finally {
      log26.trace("set multiaddrs for %p", peerId);
      log26("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (!hasPeer) {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async add(peerId, multiaddrs) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(multiaddrs)) {
      log26.error("multiaddrs must be an array of Multiaddrs");
      throw (0, import_err_code25.default)(new Error("multiaddrs must be an array of Multiaddrs"), codes3.ERR_INVALID_PARAMETERS);
    }
    log26.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log26.trace("add got write lock");
    let hasPeer;
    let peer;
    let updatedPeer;
    try {
      const addresses = await filterMultiaddrs(peerId, multiaddrs, this.addressFilter);
      if (addresses.length === 0) {
        return;
      }
      try {
        peer = await this.store.load(peerId);
        hasPeer = true;
        if ((/* @__PURE__ */ new Set([
          ...addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString()),
          ...peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2.toString())
        ])).size === peer.addresses.length) {
          return;
        }
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, { addresses });
      log26("added multiaddrs for %p", peerId);
    } finally {
      log26.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME, {
      detail: {
        peerId,
        multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
        oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
      }
    }));
    if (hasPeer === true) {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: {
          id: peerId,
          multiaddrs: updatedPeer.addresses.map((addr) => addr.multiaddr),
          protocols: updatedPeer.protocols
        }
      }));
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log26.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log26.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      await this.store.patchOrCreate(peerId, {
        addresses: []
      });
    } finally {
      log26.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME, {
        detail: {
          peerId,
          multiaddrs: [],
          oldMultiaddrs: peer == null ? [] : peer.addresses.map(({ multiaddr: multiaddr2 }) => multiaddr2)
        }
      }));
    }
  }
};
async function filterMultiaddrs(peerId, multiaddrs, addressFilter, isCertified = false) {
  return await pipe(multiaddrs, (source) => (0, import_it_foreach2.default)(source, (multiaddr2) => {
    if (!isMultiaddr(multiaddr2)) {
      log26.error("multiaddr must be an instance of Multiaddr");
      throw (0, import_err_code25.default)(new Error("multiaddr must be an instance of Multiaddr"), codes3.ERR_INVALID_PARAMETERS);
    }
  }), (source) => (0, import_it_filter5.default)(source, async (multiaddr2) => await addressFilter(peerId, multiaddr2)), (source) => (0, import_it_map2.default)(source, (multiaddr2) => {
    return {
      multiaddr: multiaddr2,
      isCertified
    };
  }), async (source) => await (0, import_it_all5.default)(source));
}

// node_modules/@libp2p/peer-store/dist/src/key-book.js
var import_err_code26 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/peer-store/node_modules/uint8arrays/dist/src/equals.js
function equals3(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/@libp2p/peer-store/dist/src/key-book.js
var log27 = logger("libp2p:peer-store:key-book");
var EVENT_NAME2 = "change:pubkey";
var PeerStoreKeyBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async set(peerId, publicKey) {
    peerId = peerIdFromPeerId(peerId);
    if (!(publicKey instanceof Uint8Array)) {
      log27.error("publicKey must be an instance of Uint8Array to store data");
      throw (0, import_err_code26.default)(new Error("publicKey must be an instance of PublicKey"), codes3.ERR_INVALID_PARAMETERS);
    }
    log27.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log27.trace("set got write lock");
    let updatedKey = false;
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
        if (peer.pubKey != null && equals3(peer.pubKey, publicKey)) {
          return;
        }
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: publicKey
      });
      updatedKey = true;
    } finally {
      log27.trace("set release write lock");
      release();
    }
    if (updatedKey) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME2, {
        detail: {
          peerId,
          publicKey,
          oldPublicKey: peer == null ? void 0 : peer.pubKey
        }
      }));
    }
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log27.trace("get await write lock");
    const release = await this.store.lock.readLock();
    log27.trace("get got write lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.pubKey;
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
    } finally {
      log27("get release write lock");
      release();
    }
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log27.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log27.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      await this.store.patchOrCreate(peerId, {
        pubKey: void 0
      });
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
    } finally {
      log27.trace("delete release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME2, {
      detail: {
        peerId,
        publicKey: void 0,
        oldPublicKey: peer == null ? void 0 : peer.pubKey
      }
    }));
  }
};

// node_modules/@libp2p/peer-store/dist/src/metadata-book.js
var import_err_code27 = __toESM(require_err_code(), 1);
var log28 = logger("libp2p:peer-store:metadata-book");
var EVENT_NAME3 = "change:metadata";
var PeerStoreMetadataBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log28.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log28.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata;
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
    } finally {
      log28.trace("get release read lock");
      release();
    }
    return /* @__PURE__ */ new Map();
  }
  async getValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log28.trace("getValue await read lock");
    const release = await this.store.lock.readLock();
    log28.trace("getValue got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.metadata.get(key);
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
    } finally {
      log28.trace("getValue release write lock");
      release();
    }
  }
  async set(peerId, metadata) {
    peerId = peerIdFromPeerId(peerId);
    if (!(metadata instanceof Map)) {
      log28.error("valid metadata must be provided to store data");
      throw (0, import_err_code27.default)(new Error("valid metadata must be provided"), codes3.ERR_INVALID_PARAMETERS);
    }
    log28.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log28.trace("set got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      await this.store.mergeOrCreate(peerId, {
        metadata
      });
    } finally {
      log28.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
      detail: {
        peerId,
        metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async setValue(peerId, key, value) {
    peerId = peerIdFromPeerId(peerId);
    if (typeof key !== "string" || !(value instanceof Uint8Array)) {
      log28.error("valid key and value must be provided to store data");
      throw (0, import_err_code27.default)(new Error("valid key and value must be provided"), codes3.ERR_INVALID_PARAMETERS);
    }
    log28.trace("setValue await write lock");
    const release = await this.store.lock.writeLock();
    log28.trace("setValue got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const existingValue = peer.metadata.get(key);
        if (existingValue != null && equals3(value, existingValue)) {
          return;
        }
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        metadata: /* @__PURE__ */ new Map([[key, value]])
      });
    } finally {
      log28.trace("setValue release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
      detail: {
        peerId,
        metadata: updatedPeer.metadata,
        oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log28.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log28.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      if (peer != null) {
        await this.store.patch(peerId, {
          metadata: /* @__PURE__ */ new Map()
        });
      }
    } finally {
      log28.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
        detail: {
          peerId,
          metadata: /* @__PURE__ */ new Map(),
          oldMetadata: peer.metadata
        }
      }));
    }
  }
  async deleteValue(peerId, key) {
    peerId = peerIdFromPeerId(peerId);
    log28.trace("deleteValue await write lock");
    const release = await this.store.lock.writeLock();
    log28.trace("deleteValue got write lock");
    let metadata;
    let peer;
    try {
      peer = await this.store.load(peerId);
      metadata = peer.metadata;
      metadata.delete(key);
      await this.store.patch(peerId, {
        metadata
      });
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
    } finally {
      log28.trace("deleteValue release write lock");
      release();
    }
    if (metadata != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME3, {
        detail: {
          peerId,
          metadata,
          oldMetadata: peer == null ? /* @__PURE__ */ new Map() : peer.metadata
        }
      }));
    }
  }
};

// node_modules/@libp2p/peer-store/dist/src/proto-book.js
var import_err_code28 = __toESM(require_err_code(), 1);
var log29 = logger("libp2p:peer-store:proto-book");
var EVENT_NAME4 = "change:protocols";
var PeerStoreProtoBook = class {
  constructor(dispatchEvent, store) {
    this.dispatchEvent = dispatchEvent;
    this.store = store;
  }
  async get(peerId) {
    log29.trace("get wait for read lock");
    const release = await this.store.lock.readLock();
    log29.trace("get got read lock");
    try {
      const peer = await this.store.load(peerId);
      return peer.protocols;
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
    } finally {
      log29.trace("get release read lock");
      release();
    }
    return [];
  }
  async set(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log29.error("protocols must be provided to store data");
      throw (0, import_err_code28.default)(new Error("protocols must be provided"), codes3.ERR_INVALID_PARAMETERS);
    }
    log29.trace("set await write lock");
    const release = await this.store.lock.writeLock();
    log29.trace("set got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
      log29("stored provided protocols for %p", peerId);
    } finally {
      log29.trace("set release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async add(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log29.error("protocols must be provided to store data");
      throw (0, import_err_code28.default)(new Error("protocols must be provided"), codes3.ERR_INVALID_PARAMETERS);
    }
    log29.trace("add await write lock");
    const release = await this.store.lock.writeLock();
    log29.trace("add got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        if ((/* @__PURE__ */ new Set([
          ...peer.protocols,
          ...protocols
        ])).size === peer.protocols.length) {
          return;
        }
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      updatedPeer = await this.store.mergeOrCreate(peerId, {
        protocols
      });
      log29("added provided protocols for %p", peerId);
    } finally {
      log29.trace("add release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async remove(peerId, protocols) {
    peerId = peerIdFromPeerId(peerId);
    if (!Array.isArray(protocols)) {
      log29.error("protocols must be provided to store data");
      throw (0, import_err_code28.default)(new Error("protocols must be provided"), codes3.ERR_INVALID_PARAMETERS);
    }
    log29.trace("remove await write lock");
    const release = await this.store.lock.writeLock();
    log29.trace("remove got write lock");
    let peer;
    let updatedPeer;
    try {
      try {
        peer = await this.store.load(peerId);
        const protocolSet = new Set(peer.protocols);
        for (const protocol of protocols) {
          protocolSet.delete(protocol);
        }
        if (peer.protocols.length === protocolSet.size) {
          return;
        }
        protocols = Array.from(protocolSet);
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      updatedPeer = await this.store.patchOrCreate(peerId, {
        protocols
      });
    } finally {
      log29.trace("remove release write lock");
      release();
    }
    this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
      detail: {
        peerId,
        protocols: updatedPeer.protocols,
        oldProtocols: peer == null ? [] : peer.protocols
      }
    }));
  }
  async delete(peerId) {
    peerId = peerIdFromPeerId(peerId);
    log29.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log29.trace("delete got write lock");
    let peer;
    try {
      try {
        peer = await this.store.load(peerId);
      } catch (err) {
        if (err.code !== codes3.ERR_NOT_FOUND) {
          throw err;
        }
      }
      await this.store.patchOrCreate(peerId, {
        protocols: []
      });
    } finally {
      log29.trace("delete release write lock");
      release();
    }
    if (peer != null) {
      this.dispatchEvent(new CustomEvent(EVENT_NAME4, {
        detail: {
          peerId,
          protocols: [],
          oldProtocols: peer.protocols
        }
      }));
    }
  }
};

// node_modules/@libp2p/peer-store/dist/src/store.js
var import_err_code29 = __toESM(require_err_code(), 1);

// node_modules/@libp2p/peer-store/node_modules/protons-runtime/dist/src/utils.js
var import_reader3 = __toESM(require_reader(), 1);
var import_reader_buffer3 = __toESM(require_reader_buffer(), 1);
var import_writer3 = __toESM(require_writer(), 1);
var import_writer_buffer3 = __toESM(require_writer_buffer(), 1);
var import_minimal3 = __toESM(require_minimal(), 1);
function configure3() {
  import_minimal3.default._configure();
  import_reader3.default._configure(import_reader_buffer3.default);
  import_writer3.default._configure(import_writer_buffer3.default);
}
configure3();
var methods3 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader3(obj) {
  for (const method of methods3) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader4(buf) {
  return patchReader3(new import_reader3.default(buf));
}
function patchWriter3(obj) {
  for (const method of methods3) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer3() {
  return patchWriter3(import_writer3.default.create());
}

// node_modules/@libp2p/peer-store/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage3(buf, codec) {
  const r = reader4(buf instanceof Uint8Array ? buf : buf.subarray());
  return codec.decode(r);
}

// node_modules/@libp2p/peer-store/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage3(message5, codec) {
  const w = writer3();
  codec.encode(message5, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/@libp2p/peer-store/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES3;
(function(CODEC_TYPES5) {
  CODEC_TYPES5[CODEC_TYPES5["VARINT"] = 0] = "VARINT";
  CODEC_TYPES5[CODEC_TYPES5["BIT64"] = 1] = "BIT64";
  CODEC_TYPES5[CODEC_TYPES5["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES5[CODEC_TYPES5["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES5[CODEC_TYPES5["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES5[CODEC_TYPES5["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES3 || (CODEC_TYPES3 = {}));
function createCodec7(name2, type, encode3, decode2) {
  return {
    name: name2,
    type,
    encode: encode3,
    decode: decode2
  };
}

// node_modules/@libp2p/peer-store/node_modules/protons-runtime/dist/src/codecs/message.js
function message3(encode3, decode2) {
  return createCodec7("message", CODEC_TYPES3.LENGTH_DELIMITED, encode3, decode2);
}

// node_modules/@libp2p/peer-store/dist/src/pb/peer.js
var Peer;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message3((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.addresses != null) {
          for (const value of obj.addresses) {
            w.uint32(10);
            Address.codec().encode(value, w, {
              writeDefaults: true
            });
          }
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(18);
            w.string(value);
          }
        }
        if (obj.metadata != null) {
          for (const value of obj.metadata) {
            w.uint32(26);
            Metadata.codec().encode(value, w, {
              writeDefaults: true
            });
          }
        }
        if (obj.pubKey != null) {
          w.uint32(34);
          w.bytes(obj.pubKey);
        }
        if (obj.peerRecordEnvelope != null) {
          w.uint32(42);
          w.bytes(obj.peerRecordEnvelope);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          addresses: [],
          protocols: [],
          metadata: []
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.addresses.push(Address.codec().decode(reader6, reader6.uint32()));
              break;
            case 2:
              obj.protocols.push(reader6.string());
              break;
            case 3:
              obj.metadata.push(Metadata.codec().decode(reader6, reader6.uint32()));
              break;
            case 4:
              obj.pubKey = reader6.bytes();
              break;
            case 5:
              obj.peerRecordEnvelope = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage3(obj, Peer2.codec());
  };
  Peer2.decode = (buf) => {
    return decodeMessage3(buf, Peer2.codec());
  };
})(Peer || (Peer = {}));
var Address;
(function(Address2) {
  let _codec;
  Address2.codec = () => {
    if (_codec == null) {
      _codec = message3((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.multiaddr != null && obj.multiaddr.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.multiaddr);
        }
        if (obj.isCertified != null) {
          w.uint32(16);
          w.bool(obj.isCertified);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          multiaddr: new Uint8Array(0)
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.multiaddr = reader6.bytes();
              break;
            case 2:
              obj.isCertified = reader6.bool();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Address2.encode = (obj) => {
    return encodeMessage3(obj, Address2.codec());
  };
  Address2.decode = (buf) => {
    return decodeMessage3(buf, Address2.codec());
  };
})(Address || (Address = {}));
var Metadata;
(function(Metadata2) {
  let _codec;
  Metadata2.codec = () => {
    if (_codec == null) {
      _codec = message3((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.key !== "") {
          w.uint32(10);
          w.string(obj.key);
        }
        if (opts.writeDefaults === true || obj.value != null && obj.value.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.value);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          key: "",
          value: new Uint8Array(0)
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.key = reader6.string();
              break;
            case 2:
              obj.value = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Metadata2.encode = (obj) => {
    return encodeMessage3(obj, Metadata2.codec());
  };
  Metadata2.decode = (buf) => {
    return decodeMessage3(buf, Metadata2.codec());
  };
})(Metadata || (Metadata = {}));

// node_modules/p-queue/dist/index.js
var import_eventemitter3 = __toESM(require_eventemitter3());

// node_modules/p-queue/node_modules/p-timeout/index.js
var TimeoutError = class extends Error {
  constructor(message5) {
    super(message5);
    this.name = "TimeoutError";
  }
};
var AbortError2 = class extends Error {
  constructor(message5) {
    super();
    this.name = "AbortError";
    this.message = message5;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError2(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout2(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message5 = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = fallback instanceof Error ? fallback : new TimeoutError(message5);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// node_modules/p-queue/dist/lower-bound.js
function lowerBound(array, value, comparator) {
  let first3 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first3 + step;
    if (comparator(array[it], value) <= 0) {
      first3 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first3;
}

// node_modules/p-queue/dist/priority-queue.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue;
var PriorityQueue = class {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, "f"), element, (a, b) => b.priority - a.priority);
    __classPrivateFieldGet(this, _PriorityQueue_queue, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet(this, _PriorityQueue_queue, "f").length;
  }
};
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();

// node_modules/p-queue/dist/index.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances;
var _PQueue_carryoverConcurrencyCount;
var _PQueue_isIntervalIgnored;
var _PQueue_intervalCount;
var _PQueue_intervalCap;
var _PQueue_interval;
var _PQueue_intervalEnd;
var _PQueue_intervalId;
var _PQueue_timeoutId;
var _PQueue_queue;
var _PQueue_queueClass;
var _PQueue_pendingCount;
var _PQueue_concurrency;
var _PQueue_isPaused;
var _PQueue_throwOnTimeout;
var _PQueue_doesIntervalAllowAnother_get;
var _PQueue_doesConcurrentAllowAnother_get;
var _PQueue_next;
var _PQueue_emitEvents;
var _PQueue_onResumeInterval;
var _PQueue_isIntervalPaused_get;
var _PQueue_tryToStartAnother;
var _PQueue_initializeIntervalIfNeeded;
var _PQueue_onInterval;
var _PQueue_processQueue;
var _PQueue_onEvent;
var timeoutError = new TimeoutError();
var AbortError3 = class extends Error {
};
var PQueue = class extends import_eventemitter3.default {
  constructor(options) {
    var _a2, _b, _c, _d;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pendingCount.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a2 = options.intervalCap) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(fn, options = {}) {
    return new Promise((resolve, reject) => {
      const run = async () => {
        var _a2;
        var _b, _c;
        __classPrivateFieldSet(this, _PQueue_pendingCount, (_b = __classPrivateFieldGet2(this, _PQueue_pendingCount, "f"), _b++, _b), "f");
        __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet2(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a2 = options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            reject(new AbortError3("The task was aborted."));
            return;
          }
          const operation = this.timeout === void 0 && options.timeout === void 0 ? fn({ signal: options.signal }) : pTimeout2(Promise.resolve(fn({ signal: options.signal })), options.timeout === void 0 ? this.timeout : options.timeout, () => {
            if (options.throwOnTimeout === void 0 ? __classPrivateFieldGet2(this, _PQueue_throwOnTimeout, "f") : options.throwOnTimeout) {
              reject(timeoutError);
            }
            return void 0;
          });
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          reject(error);
          this.emit("error", error);
        }
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_next).call(this);
      };
      __classPrivateFieldGet2(this, _PQueue_queue, "f").enqueue(run, options);
      __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
      this.emit("add");
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  start() {
    if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, true, "f");
  }
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet2(this, _PQueue_queueClass, "f"))(), "f");
  }
  async onEmpty() {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet2(this, _PQueue_queue, "f").size < limit);
  }
  async onIdle() {
    if (__classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  get size() {
    return __classPrivateFieldGet2(this, _PQueue_queue, "f").size;
  }
  sizeBy(options) {
    return __classPrivateFieldGet2(this, _PQueue_queue, "f").filter(options).length;
  }
  get pending() {
    return __classPrivateFieldGet2(this, _PQueue_pendingCount, "f");
  }
  get isPaused() {
    return __classPrivateFieldGet2(this, _PQueue_isPaused, "f");
  }
};
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pendingCount = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet2(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") < __classPrivateFieldGet2(this, _PQueue_concurrency, "f");
}, _PQueue_next = function _PQueue_next2() {
  var _a2;
  __classPrivateFieldSet(this, _PQueue_pendingCount, (_a2 = __classPrivateFieldGet2(this, _PQueue_pendingCount, "f"), _a2--, _a2), "f");
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, _PQueue_emitEvents = function _PQueue_emitEvents2() {
  this.emit("empty");
  if (__classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0) {
    this.emit("idle");
  }
}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f") === void 0) {
    const delay = __classPrivateFieldGet2(this, _PQueue_intervalEnd, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet2(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet2(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_emitEvents).call(this);
    return false;
  }
  if (!__classPrivateFieldGet2(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet2(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet2(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet2(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet2(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet2(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet2(this, _PQueue_interval, "f"), "f");
}, _PQueue_onInterval = function _PQueue_onInterval2() {
  if (__classPrivateFieldGet2(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet2(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet2(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet2(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet2(this, _PQueue_pendingCount, "f") : 0, "f");
  __classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function _PQueue_processQueue2() {
  while (__classPrivateFieldGet2(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter4) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter4 && !filter4()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};

// node_modules/mortice/dist/src/constants.js
var WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
var WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
var MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
var WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
var WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
var MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";

// node_modules/observable-webworkers/dist/src/index.js
var events = {};
var observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn);
};
observable.removeEventListener = (type, fn) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn) => fn(worker, event));
};
var src_default = observable;

// node_modules/mortice/dist/src/browser.js
var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return await new Promise((resolve) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
var makeWorkerLockRequest = (name2, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name2
    });
    return await new Promise((resolve) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name2
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
var defaultOptions4 = {
  singleProcess: false
};
var browser_default = (options) => {
  options = Object.assign({}, defaultOptions4, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    src_default.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};

// node_modules/mortice/dist/src/index.js
var mutexes = {};
var implementation;
async function createReleaseable(queue, options) {
  let res;
  const p = new Promise((resolve) => {
    res = resolve;
  });
  void queue.add(async () => await pTimeout((async () => {
    return await new Promise((resolve) => {
      res(() => {
        resolve();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return await p;
}
var createMutex = (name2, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name2, options),
      writeLock: implementation.writeLock(name2, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return await createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        return await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return await readPromise;
    },
    async writeLock() {
      readQueue = null;
      return await createReleaseable(masterQueue, options);
    }
  };
};
var defaultOptions5 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions5, options);
  if (implementation == null) {
    implementation = browser_default(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}

// node_modules/@libp2p/peer-store/dist/src/store.js
var log30 = logger("libp2p:peer-store:store");
var NAMESPACE_COMMON = "/peers/";
var PersistentStore = class {
  constructor(components) {
    this.components = components;
    this.lock = createMortice({
      name: "peer-store",
      singleProcess: true
    });
  }
  _peerIdToDatastoreKey(peerId) {
    if (peerId.type == null) {
      log30.error("peerId must be an instance of peer-id to store data");
      throw (0, import_err_code29.default)(new Error("peerId must be an instance of peer-id"), codes3.ERR_INVALID_PARAMETERS);
    }
    const b32key = peerId.toCID().toString();
    return new Key(`${NAMESPACE_COMMON}${b32key}`);
  }
  async has(peerId) {
    return await this.components.datastore.has(this._peerIdToDatastoreKey(peerId));
  }
  async delete(peerId) {
    await this.components.datastore.delete(this._peerIdToDatastoreKey(peerId));
  }
  async load(peerId) {
    const buf = await this.components.datastore.get(this._peerIdToDatastoreKey(peerId));
    const peer = Peer.decode(buf);
    const metadata = /* @__PURE__ */ new Map();
    for (const meta of peer.metadata) {
      metadata.set(meta.key, meta.value);
    }
    return {
      ...peer,
      id: peerId,
      addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {
        return {
          multiaddr: multiaddr(ma),
          isCertified: isCertified ?? false
        };
      }),
      metadata,
      pubKey: peer.pubKey ?? void 0,
      peerRecordEnvelope: peer.peerRecordEnvelope ?? void 0
    };
  }
  async save(peer) {
    if (peer.pubKey != null && peer.id.publicKey != null && !equals3(peer.pubKey, peer.id.publicKey)) {
      log30.error("peer publicKey bytes do not match peer id publicKey bytes");
      throw (0, import_err_code29.default)(new Error("publicKey bytes do not match peer id publicKey bytes"), codes3.ERR_INVALID_PARAMETERS);
    }
    const addressSet = /* @__PURE__ */ new Set();
    const addresses = peer.addresses.filter((address) => {
      if (addressSet.has(address.multiaddr.toString())) {
        return false;
      }
      addressSet.add(address.multiaddr.toString());
      return true;
    }).sort((a, b) => {
      return a.multiaddr.toString().localeCompare(b.multiaddr.toString());
    }).map(({ multiaddr: multiaddr2, isCertified }) => ({
      multiaddr: multiaddr2.bytes,
      isCertified
    }));
    const metadata = [];
    [...peer.metadata.keys()].sort().forEach((key) => {
      const value = peer.metadata.get(key);
      if (value != null) {
        metadata.push({ key, value });
      }
    });
    const buf = Peer.encode({
      addresses,
      protocols: peer.protocols.sort(),
      pubKey: peer.pubKey,
      metadata,
      peerRecordEnvelope: peer.peerRecordEnvelope
    });
    await this.components.datastore.put(this._peerIdToDatastoreKey(peer.id), buf.subarray());
    return await this.load(peer.id);
  }
  async patch(peerId, data) {
    const peer = await this.load(peerId);
    return await this._patch(peerId, data, peer);
  }
  async patchOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._patch(peerId, data, peer);
  }
  async _patch(peerId, data, peer) {
    return await this.save({
      ...peer,
      ...data,
      id: peerId
    });
  }
  async merge(peerId, data) {
    const peer = await this.load(peerId);
    return await this._merge(peerId, data, peer);
  }
  async mergeOrCreate(peerId, data) {
    let peer;
    try {
      peer = await this.load(peerId);
    } catch (err) {
      if (err.code !== codes3.ERR_NOT_FOUND) {
        throw err;
      }
      peer = { id: peerId, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
    }
    return await this._merge(peerId, data, peer);
  }
  async _merge(peerId, data, peer) {
    const addresses = /* @__PURE__ */ new Map();
    peer.addresses.forEach((addr) => {
      addresses.set(addr.multiaddr.toString(), addr.isCertified);
    });
    (data.addresses ?? []).forEach((addr) => {
      const addrString = addr.multiaddr.toString();
      const isAlreadyCertified = Boolean(addresses.get(addrString));
      const isCertified = isAlreadyCertified || addr.isCertified;
      addresses.set(addrString, isCertified);
    });
    return await this.save({
      id: peerId,
      addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {
        return {
          multiaddr: multiaddr(addrStr),
          isCertified
        };
      }),
      protocols: Array.from(/* @__PURE__ */ new Set([
        ...peer.protocols ?? [],
        ...data.protocols ?? []
      ])),
      metadata: new Map([
        ...peer.metadata?.entries() ?? [],
        ...data.metadata?.entries() ?? []
      ]),
      pubKey: data.pubKey ?? (peer != null ? peer.pubKey : void 0),
      peerRecordEnvelope: data.peerRecordEnvelope ?? (peer != null ? peer.peerRecordEnvelope : void 0)
    });
  }
  async *all() {
    for await (const key of this.components.datastore.queryKeys({
      prefix: NAMESPACE_COMMON
    })) {
      const base32Str = key.toString().split("/")[2];
      const buf = base32.decode(base32Str);
      yield this.load(peerIdFromBytes(buf));
    }
  }
};

// node_modules/@libp2p/peer-store/dist/src/index.js
var import_err_code30 = __toESM(require_err_code());

// node_modules/@libp2p/peer-store/dist/src/pb/tags.js
var Tags;
(function(Tags2) {
  let _codec;
  Tags2.codec = () => {
    if (_codec == null) {
      _codec = message3((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.tags != null) {
          for (const value of obj.tags) {
            w.uint32(10);
            Tag.codec().encode(value, w, {
              writeDefaults: true
            });
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          tags: []
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.tags.push(Tag.codec().decode(reader6, reader6.uint32()));
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tags2.encode = (obj) => {
    return encodeMessage3(obj, Tags2.codec());
  };
  Tags2.decode = (buf) => {
    return decodeMessage3(buf, Tags2.codec());
  };
})(Tags || (Tags = {}));
var Tag;
(function(Tag2) {
  let _codec;
  Tag2.codec = () => {
    if (_codec == null) {
      _codec = message3((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.name !== "") {
          w.uint32(10);
          w.string(obj.name);
        }
        if (obj.value != null) {
          w.uint32(16);
          w.uint32(obj.value);
        }
        if (obj.expiry != null) {
          w.uint32(24);
          w.uint64(obj.expiry);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          name: ""
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.name = reader6.string();
              break;
            case 2:
              obj.value = reader6.uint32();
              break;
            case 3:
              obj.expiry = reader6.uint64();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Tag2.encode = (obj) => {
    return encodeMessage3(obj, Tag2.codec());
  };
  Tag2.decode = (buf) => {
    return decodeMessage3(buf, Tag2.codec());
  };
})(Tag || (Tag = {}));

// node_modules/@libp2p/peer-store/dist/src/index.js
var log31 = logger("libp2p:peer-store");
var PersistentPeerStore = class extends EventEmitter {
  constructor(components, init = {}) {
    super();
    this.components = components;
    this.store = new PersistentStore(components);
    this.addressBook = new PeerStoreAddressBook(this.dispatchEvent.bind(this), this.store, init.addressFilter);
    this.keyBook = new PeerStoreKeyBook(this.dispatchEvent.bind(this), this.store);
    this.metadataBook = new PeerStoreMetadataBook(this.dispatchEvent.bind(this), this.store);
    this.protoBook = new PeerStoreProtoBook(this.dispatchEvent.bind(this), this.store);
  }
  async forEach(fn) {
    log31.trace("getPeers await read lock");
    const release = await this.store.lock.readLock();
    log31.trace("getPeers got read lock");
    try {
      for await (const peer of this.store.all()) {
        if (peer.id.equals(this.components.peerId)) {
          continue;
        }
        fn(peer);
      }
    } finally {
      log31.trace("getPeers release read lock");
      release();
    }
  }
  async all() {
    const output = [];
    await this.forEach((peer) => {
      output.push(peer);
    });
    return output;
  }
  async delete(peerId) {
    log31.trace("delete await write lock");
    const release = await this.store.lock.writeLock();
    log31.trace("delete got write lock");
    try {
      await this.store.delete(peerId);
    } finally {
      log31.trace("delete release write lock");
      release();
    }
  }
  async get(peerId) {
    log31.trace("get await read lock");
    const release = await this.store.lock.readLock();
    log31.trace("get got read lock");
    try {
      return await this.store.load(peerId);
    } finally {
      log31.trace("get release read lock");
      release();
    }
  }
  async has(peerId) {
    log31.trace("has await read lock");
    const release = await this.store.lock.readLock();
    log31.trace("has got read lock");
    try {
      return await this.store.has(peerId);
    } finally {
      log31.trace("has release read lock");
      release();
    }
  }
  async tagPeer(peerId, tag, options = {}) {
    const providedValue = options.value ?? 0;
    const value = Math.round(providedValue);
    const ttl = options.ttl ?? void 0;
    if (value !== providedValue || value < 0 || value > 100) {
      throw (0, import_err_code30.default)(new Error("Tag value must be between 0-100"), "ERR_TAG_VALUE_OUT_OF_BOUNDS");
    }
    const buf = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf != null) {
      tags = Tags.decode(buf).tags;
    }
    for (const t of tags) {
      if (t.name === tag) {
        throw (0, import_err_code30.default)(new Error("Peer already tagged"), "ERR_DUPLICATE_TAG");
      }
    }
    tags.push({
      name: tag,
      value,
      expiry: ttl == null ? void 0 : BigInt(Date.now() + ttl)
    });
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async unTagPeer(peerId, tag) {
    const buf = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf != null) {
      tags = Tags.decode(buf).tags;
    }
    tags = tags.filter((t) => t.name !== tag);
    await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags }).subarray());
  }
  async getTags(peerId) {
    const buf = await this.metadataBook.getValue(peerId, "tags");
    let tags = [];
    if (buf != null) {
      tags = Tags.decode(buf).tags;
    }
    const now = BigInt(Date.now());
    const unexpiredTags = tags.filter((tag) => tag.expiry == null || tag.expiry > now);
    if (unexpiredTags.length !== tags.length) {
      await this.metadataBook.setValue(peerId, "tags", Tags.encode({ tags: unexpiredTags }).subarray());
    }
    return unexpiredTags.map((t) => ({
      name: t.name,
      value: t.value ?? 0
    }));
  }
};

// node_modules/libp2p/dist/src/dht/dht-content-routing.js
var import_err_code31 = __toESM(require_err_code(), 1);
var DHTContentRouting = class {
  constructor(dht) {
    this.dht = dht;
  }
  async provide(cid) {
    await drain2(this.dht.provide(cid));
  }
  async *findProviders(cid, options = {}) {
    for await (const event of this.dht.findProviders(cid, options)) {
      if (event.name === "PROVIDER") {
        yield* event.providers;
      }
    }
  }
  async put(key, value, options) {
    await drain2(this.dht.put(key, value, options));
  }
  async get(key, options) {
    for await (const event of this.dht.get(key, options)) {
      if (event.name === "VALUE") {
        return event.value;
      }
    }
    throw (0, import_err_code31.default)(new Error("Not found"), "ERR_NOT_FOUND");
  }
};

// node_modules/libp2p/dist/src/components.js
var import_err_code32 = __toESM(require_err_code(), 1);
var DefaultComponents = class {
  constructor(init = {}) {
    this._started = false;
    this._peerId = init.peerId;
    this._addressManager = init.addressManager;
    this._peerStore = init.peerStore;
    this._upgrader = init.upgrader;
    this._metrics = init.metrics;
    this._registrar = init.registrar;
    this._connectionManager = init.connectionManager;
    this._transportManager = init.transportManager;
    this._connectionGater = init.connectionGater;
    this._contentRouting = init.contentRouting;
    this._peerRouting = init.peerRouting;
    this._datastore = init.datastore;
    this._connectionProtector = init.connectionProtector;
    this._dht = init.dht;
    this._pubsub = init.pubsub;
    this._dialer = init.dialer;
  }
  isStarted() {
    return this._started;
  }
  async beforeStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStart != null) {
        await startable.beforeStart();
      }
    }));
  }
  async start() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.start();
    }));
    this._started = true;
  }
  async afterStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStart != null) {
        await startable.afterStart();
      }
    }));
  }
  async beforeStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStop != null) {
        await startable.beforeStop();
      }
    }));
  }
  async stop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.stop();
    }));
    this._started = false;
  }
  async afterStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStop != null) {
        await startable.afterStop();
      }
    }));
  }
  get peerId() {
    if (this._peerId == null) {
      throw (0, import_err_code32.default)(new Error("peerId not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerId;
  }
  set peerId(peerId) {
    this._peerId = peerId;
  }
  get addressManager() {
    if (this._addressManager == null) {
      throw (0, import_err_code32.default)(new Error("addressManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._addressManager;
  }
  set addressManager(addressManager) {
    this._addressManager = addressManager;
  }
  get peerStore() {
    if (this._peerStore == null) {
      throw (0, import_err_code32.default)(new Error("peerStore not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerStore;
  }
  set peerStore(peerStore) {
    this._peerStore = peerStore;
  }
  get upgrader() {
    if (this._upgrader == null) {
      throw (0, import_err_code32.default)(new Error("upgrader not set"), "ERR_SERVICE_MISSING");
    }
    return this._upgrader;
  }
  set upgrader(upgrader) {
    this._upgrader = upgrader;
  }
  get registrar() {
    if (this._registrar == null) {
      throw (0, import_err_code32.default)(new Error("registrar not set"), "ERR_SERVICE_MISSING");
    }
    return this._registrar;
  }
  set registrar(registrar) {
    this._registrar = registrar;
  }
  get connectionManager() {
    if (this._connectionManager == null) {
      throw (0, import_err_code32.default)(new Error("connectionManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._connectionManager;
  }
  set connectionManager(connectionManager) {
    this._connectionManager = connectionManager;
  }
  get transportManager() {
    if (this._transportManager == null) {
      throw (0, import_err_code32.default)(new Error("transportManager not set"), "ERR_SERVICE_MISSING");
    }
    return this._transportManager;
  }
  set transportManager(transportManager) {
    this._transportManager = transportManager;
  }
  get connectionGater() {
    if (this._connectionGater == null) {
      throw (0, import_err_code32.default)(new Error("connectionGater not set"), "ERR_SERVICE_MISSING");
    }
    return this._connectionGater;
  }
  set connectionGater(connectionGater) {
    this._connectionGater = connectionGater;
  }
  get contentRouting() {
    if (this._contentRouting == null) {
      throw (0, import_err_code32.default)(new Error("contentRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this._contentRouting;
  }
  set contentRouting(contentRouting) {
    this._contentRouting = contentRouting;
  }
  get peerRouting() {
    if (this._peerRouting == null) {
      throw (0, import_err_code32.default)(new Error("peerRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this._peerRouting;
  }
  set peerRouting(peerRouting) {
    this._peerRouting = peerRouting;
  }
  get datastore() {
    if (this._datastore == null) {
      throw (0, import_err_code32.default)(new Error("datastore not set"), "ERR_SERVICE_MISSING");
    }
    return this._datastore;
  }
  set datastore(datastore) {
    this._datastore = datastore;
  }
  get connectionProtector() {
    return this._connectionProtector;
  }
  set connectionProtector(connectionProtector) {
    this._connectionProtector = connectionProtector;
  }
  get dialer() {
    if (this._dialer == null) {
      throw (0, import_err_code32.default)(new Error("dialer not set"), "ERR_SERVICE_MISSING");
    }
    return this._dialer;
  }
  set dialer(dialer) {
    this._dialer = dialer;
  }
  get metrics() {
    return this._metrics;
  }
  set metrics(metrics) {
    this._metrics = metrics;
  }
  get dht() {
    return this._dht;
  }
  set dht(dht) {
    this._dht = dht;
  }
  get pubsub() {
    return this._pubsub;
  }
  set pubsub(pubsub) {
    this._pubsub = pubsub;
  }
};

// node_modules/dns-over-http-resolver/dist/src/index.js
var import_debug = __toESM(require_browser());
var import_receptacle = __toESM(require_receptacle());

// node_modules/native-fetch/esm/src/index.js
var globalFetch = globalThis.fetch;
var globalHeaders = globalThis.Headers;
var globalRequest = globalThis.Request;
var globalResponse = globalThis.Response;

// node_modules/dns-over-http-resolver/dist/src/utils.js
function buildResource(serverResolver, hostname, recordType) {
  return `${serverResolver}?name=${hostname}&type=${recordType}`;
}
async function request(resource, signal) {
  const req = await globalFetch(resource, {
    headers: new globalHeaders({
      accept: "application/dns-json"
    }),
    signal
  });
  const res = await req.json();
  return res;
}
function getCacheKey(hostname, recordType) {
  return `${recordType}_${hostname}`;
}

// node_modules/dns-over-http-resolver/dist/src/index.js
var log32 = Object.assign((0, import_debug.default)("dns-over-http-resolver"), {
  error: (0, import_debug.default)("dns-over-http-resolver:error")
});
var Resolver = class {
  constructor(options = {}) {
    this._cache = new import_receptacle.default({ max: options?.maxCache ?? 100 });
    this._TXTcache = new import_receptacle.default({ max: options?.maxCache ?? 100 });
    this._servers = [
      "https://cloudflare-dns.com/dns-query",
      "https://dns.google/resolve"
    ];
    this._request = options.request ?? request;
    this._abortControllers = [];
  }
  cancel() {
    this._abortControllers.forEach((controller) => controller.abort());
  }
  getServers() {
    return this._servers;
  }
  _getShuffledServers() {
    const newServers = [...this._servers];
    for (let i = newServers.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * i);
      const temp = newServers[i];
      newServers[i] = newServers[j];
      newServers[j] = temp;
    }
    return newServers;
  }
  setServers(servers) {
    this._servers = servers;
  }
  async resolve(hostname, rrType = "A") {
    switch (rrType) {
      case "A":
        return await this.resolve4(hostname);
      case "AAAA":
        return await this.resolve6(hostname);
      case "TXT":
        return await this.resolveTxt(hostname);
      default:
        throw new Error(`${rrType} is not supported`);
    }
  }
  async resolve4(hostname) {
    const recordType = "A";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log32.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryA ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  async resolve6(hostname) {
    const recordType = "AAAA";
    const cached = this._cache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => a.data);
        const ttl = Math.min(...response.Answer.map((a) => a.TTL));
        this._cache.set(getCacheKey(hostname, recordType), data, { ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log32.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryAaaa ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  async resolveTxt(hostname) {
    const recordType = "TXT";
    const cached = this._TXTcache.get(getCacheKey(hostname, recordType));
    if (cached != null) {
      return cached;
    }
    let aborted = false;
    for (const server of this._getShuffledServers()) {
      const controller = new AbortController();
      this._abortControllers.push(controller);
      try {
        const response = await this._request(buildResource(server, hostname, recordType), controller.signal);
        const data = response.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
        const ttl = Math.min(...response.Answer.map((a) => a.TTL));
        this._TXTcache.set(getCacheKey(hostname, recordType), data, { ttl });
        return data;
      } catch (err) {
        if (controller.signal.aborted) {
          aborted = true;
        }
        log32.error(`${server} could not resolve ${hostname} record ${recordType}`);
      } finally {
        this._abortControllers = this._abortControllers.filter((c) => c !== controller);
      }
    }
    if (aborted) {
      throw Object.assign(new Error("queryTxt ECANCELLED"), {
        code: "ECANCELLED"
      });
    }
    throw new Error(`Could not resolve ${hostname} record ${recordType}`);
  }
  clearCache() {
    this._cache.clear();
    this._TXTcache.clear();
  }
};
var src_default2 = Resolver;

// node_modules/@multiformats/multiaddr/dist/src/resolvers/dns.browser.js
var dns_browser_default = src_default2;

// node_modules/@multiformats/multiaddr/dist/src/resolvers/index.js
var { code: dnsaddrCode } = getProtocol("dnsaddr");
async function dnsaddrResolver(addr, options = {}) {
  const resolver = new dns_browser_default();
  if (options.signal != null) {
    options.signal.addEventListener("abort", () => {
      resolver.cancel();
    });
  }
  const peerId = addr.getPeerId();
  const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? [];
  if (hostname == null) {
    throw new Error("No hostname found in multiaddr");
  }
  const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
  let addresses = records.flat().map((a) => a.split("=")[1]);
  if (peerId != null) {
    addresses = addresses.filter((entry) => entry.includes(peerId));
  }
  return addresses;
}

// node_modules/libp2p/dist/src/config.js
var import_err_code33 = __toESM(require_err_code(), 1);
var DefaultConfig = {
  addresses: {
    listen: [],
    announce: [],
    noAnnounce: [],
    announceFilter: (multiaddrs) => multiaddrs
  },
  connectionManager: {
    maxConnections: 300,
    minConnections: 50,
    autoDial: true,
    autoDialInterval: 1e4,
    maxParallelDials: MAX_PARALLEL_DIALS,
    maxDialsPerPeer: MAX_PER_PEER_DIALS,
    dialTimeout: DIAL_TIMEOUT,
    inboundUpgradeTimeout: INBOUND_UPGRADE_TIMEOUT,
    resolvers: {
      dnsaddr: dnsaddrResolver
    },
    addressSorter: publicAddressesFirst
  },
  connectionGater: {},
  transportManager: {
    faultTolerance: FaultTolerance.FATAL_ALL
  },
  metrics: {
    enabled: false,
    computeThrottleMaxQueueSize: 1e3,
    computeThrottleTimeout: 2e3,
    movingAverageIntervals: [
      60 * 1e3,
      5 * 60 * 1e3,
      15 * 60 * 1e3
    ],
    maxOldPeersRetention: 50
  },
  peerRouting: {
    refreshManager: {
      enabled: true,
      interval: 6e5,
      bootDelay: 1e4
    }
  },
  nat: {
    enabled: true,
    ttl: 7200,
    keepAlive: true
  },
  relay: {
    enabled: true,
    advertise: {
      bootDelay: ADVERTISE_BOOT_DELAY,
      enabled: false,
      ttl: ADVERTISE_TTL
    },
    hop: {
      enabled: false,
      active: false,
      timeout: 3e4
    },
    autoRelay: {
      enabled: false,
      maxListeners: 2
    }
  },
  identify: {
    protocolPrefix: "ipfs",
    host: {
      agentVersion: AGENT_VERSION
    },
    timeout: 6e4,
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    maxPushIncomingStreams: 1,
    maxPushOutgoingStreams: 1
  },
  ping: {
    protocolPrefix: "ipfs",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  },
  fetch: {
    protocolPrefix: "libp2p",
    maxInboundStreams: 1,
    maxOutboundStreams: 1,
    timeout: 1e4
  }
};
function validateConfig(opts) {
  const resultingOptions = merge_options_default(DefaultConfig, opts);
  if (resultingOptions.transports == null || resultingOptions.transports.length < 1) {
    throw (0, import_err_code33.default)(new Error(messages.ERR_TRANSPORTS_REQUIRED), codes.ERR_TRANSPORTS_REQUIRED);
  }
  if (resultingOptions.connectionEncryption == null || resultingOptions.connectionEncryption.length === 0) {
    throw (0, import_err_code33.default)(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);
  }
  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) {
    throw (0, import_err_code33.default)(new Error(messages.ERR_PROTECTOR_REQUIRED), codes.ERR_PROTECTOR_REQUIRED);
  }
  if (resultingOptions.identify.host.agentVersion === AGENT_VERSION) {
    if (isNode || isElectronMain) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
    } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
      resultingOptions.identify.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
    }
  }
  return resultingOptions;
}

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/dist/src/util/as-uint8array.js
function asUint8Array5(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/dist/src/alloc.js
function allocUnsafe5(size = 0) {
  if (globalThis.Buffer?.allocUnsafe != null) {
    return asUint8Array5(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}

// node_modules/@libp2p/peer-id-factory/node_modules/uint8arrays/dist/src/util/bases.js
function createCodec8(name2, prefix, encode3, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode3
    },
    decoder: {
      decode: decode2
    }
  };
}
var string5 = createCodec8("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii5 = createCodec8("ascii", "a", (buf) => {
  let string6 = "a";
  for (let i = 0; i < buf.length; i++) {
    string6 += String.fromCharCode(buf[i]);
  }
  return string6;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe5(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
var BASES5 = {
  utf8: string5,
  "utf-8": string5,
  hex: bases.base16,
  latin1: ascii5,
  ascii: ascii5,
  binary: ascii5,
  ...bases
};

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/utils.js
var import_reader4 = __toESM(require_reader(), 1);
var import_reader_buffer4 = __toESM(require_reader_buffer(), 1);
var import_writer4 = __toESM(require_writer(), 1);
var import_writer_buffer4 = __toESM(require_writer_buffer(), 1);
var import_minimal4 = __toESM(require_minimal(), 1);
function configure4() {
  import_minimal4.default._configure();
  import_reader4.default._configure(import_reader_buffer4.default);
  import_writer4.default._configure(import_writer_buffer4.default);
}
configure4();
var methods4 = [
  "uint64",
  "int64",
  "sint64",
  "fixed64",
  "sfixed64"
];
function patchReader4(obj) {
  for (const method of methods4) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function() {
      return BigInt(original.call(this).toString());
    };
  }
  return obj;
}
function reader5(buf) {
  return patchReader4(new import_reader4.default(buf));
}
function patchWriter4(obj) {
  for (const method of methods4) {
    if (obj[method] == null) {
      continue;
    }
    const original = obj[method];
    obj[method] = function(val) {
      return original.call(this, val.toString());
    };
  }
  return obj;
}
function writer4() {
  return patchWriter4(import_writer4.default.create());
}

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/decode.js
function decodeMessage4(buf, codec) {
  const r = reader5(buf instanceof Uint8Array ? buf : buf.subarray());
  return codec.decode(r);
}

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/encode.js
function encodeMessage4(message5, codec) {
  const w = writer4();
  codec.encode(message5, w, {
    lengthDelimited: false
  });
  return w.finish();
}

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/codec.js
var CODEC_TYPES4;
(function(CODEC_TYPES5) {
  CODEC_TYPES5[CODEC_TYPES5["VARINT"] = 0] = "VARINT";
  CODEC_TYPES5[CODEC_TYPES5["BIT64"] = 1] = "BIT64";
  CODEC_TYPES5[CODEC_TYPES5["LENGTH_DELIMITED"] = 2] = "LENGTH_DELIMITED";
  CODEC_TYPES5[CODEC_TYPES5["START_GROUP"] = 3] = "START_GROUP";
  CODEC_TYPES5[CODEC_TYPES5["END_GROUP"] = 4] = "END_GROUP";
  CODEC_TYPES5[CODEC_TYPES5["BIT32"] = 5] = "BIT32";
})(CODEC_TYPES4 || (CODEC_TYPES4 = {}));
function createCodec9(name2, type, encode3, decode2) {
  return {
    name: name2,
    type,
    encode: encode3,
    decode: decode2
  };
}

// node_modules/@libp2p/peer-id-factory/node_modules/protons-runtime/dist/src/codecs/message.js
function message4(encode3, decode2) {
  return createCodec9("message", CODEC_TYPES4.LENGTH_DELIMITED, encode3, decode2);
}

// node_modules/@libp2p/peer-id-factory/dist/src/proto.js
var PeerIdProto;
(function(PeerIdProto2) {
  let _codec;
  PeerIdProto2.codec = () => {
    if (_codec == null) {
      _codec = message4((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (opts.writeDefaults === true || obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.pubKey != null) {
          w.uint32(18);
          w.bytes(obj.pubKey);
        }
        if (obj.privKey != null) {
          w.uint32(26);
          w.bytes(obj.privKey);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader6, length) => {
        const obj = {
          id: new Uint8Array(0)
        };
        const end = length == null ? reader6.len : reader6.pos + length;
        while (reader6.pos < end) {
          const tag = reader6.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader6.bytes();
              break;
            case 2:
              obj.pubKey = reader6.bytes();
              break;
            case 3:
              obj.privKey = reader6.bytes();
              break;
            default:
              reader6.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  PeerIdProto2.encode = (obj) => {
    return encodeMessage4(obj, PeerIdProto2.codec());
  };
  PeerIdProto2.decode = (buf) => {
    return decodeMessage4(buf, PeerIdProto2.codec());
  };
})(PeerIdProto || (PeerIdProto = {}));

// node_modules/@libp2p/peer-id-factory/dist/src/index.js
var createEd25519PeerId = async () => {
  const key = await generateKeyPair("Ed25519");
  const id = await createFromPrivKey(key);
  if (id.type === "Ed25519") {
    return id;
  }
  throw new Error(`Generated unexpected PeerId type "${id.type}"`);
};
async function createFromPrivKey(privateKey) {
  return await peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey));
}

// node_modules/libp2p/node_modules/uint8arrays/dist/src/concat.js
function concat(arrays, length) {
  if (length == null) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe2(length);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array2(output);
}

// node_modules/libp2p/dist/src/libp2p.js
var import_err_code38 = __toESM(require_err_code(), 1);

// node_modules/libp2p/dist/src/dht/dummy-dht.js
var import_err_code34 = __toESM(require_err_code(), 1);
var DummyDHT = class extends EventEmitter {
  get [symbol]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/dummy-dht";
  }
  get wan() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  get lan() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  get() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  findProviders() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  findPeer() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  getClosestPeers() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  provide() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  put() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  async getMode() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  async setMode() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
  async refreshRoutingTable() {
    throw (0, import_err_code34.default)(new Error(messages.DHT_DISABLED), codes.DHT_DISABLED);
  }
};

// node_modules/libp2p/dist/src/pubsub/dummy-pubsub.js
var import_err_code35 = __toESM(require_err_code(), 1);
var DummyPubSub = class extends EventEmitter {
  constructor() {
    super(...arguments);
    this.topicValidators = /* @__PURE__ */ new Map();
  }
  isStarted() {
    return false;
  }
  start() {
  }
  stop() {
  }
  get globalSignaturePolicy() {
    throw (0, import_err_code35.default)(new Error(messages.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  get multicodecs() {
    throw (0, import_err_code35.default)(new Error(messages.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  getPeers() {
    throw (0, import_err_code35.default)(new Error(messages.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  getTopics() {
    throw (0, import_err_code35.default)(new Error(messages.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  subscribe() {
    throw (0, import_err_code35.default)(new Error(messages.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  unsubscribe() {
    throw (0, import_err_code35.default)(new Error(messages.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  getSubscribers() {
    throw (0, import_err_code35.default)(new Error(messages.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
  async publish() {
    throw (0, import_err_code35.default)(new Error(messages.PUBSUB_DISABLED), codes.ERR_PUBSUB_DISABLED);
  }
};

// node_modules/libp2p/dist/src/connection-manager/dialer/index.js
var import_err_code37 = __toESM(require_err_code(), 1);
var import_timeout_abort_controller8 = __toESM(require_timeout_abort_controller(), 1);
var import_any_signal2 = __toESM(require_any_signal(), 1);
var import_events24 = __toESM(require_events(), 1);

// node_modules/libp2p/dist/src/connection-manager/dialer/dial-request.js
var import_err_code36 = __toESM(require_err_code(), 1);
var import_any_signal = __toESM(require_any_signal(), 1);
var import_p_fifo = __toESM(require_p_fifo(), 1);
var import_events23 = __toESM(require_events(), 1);
var log33 = logger("libp2p:dialer:dial-request");
var DialRequest = class {
  constructor(options) {
    const { addrs, dialAction, dialer } = options;
    this.addrs = addrs;
    this.dialer = dialer;
    this.dialAction = dialAction;
  }
  async run(options = {}) {
    const tokens = this.dialer.getTokens(this.addrs.length);
    if (tokens.length < 1) {
      throw (0, import_err_code36.default)(new Error("No dial tokens available"), codes.ERR_NO_DIAL_TOKENS);
    }
    const tokenHolder = new import_p_fifo.default();
    for (const token of tokens) {
      void tokenHolder.push(token).catch((err) => {
        log33.error(err);
      });
    }
    const dialAbortControllers = this.addrs.map(() => {
      const controller = new AbortController();
      try {
        (0, import_events23.setMaxListeners)?.(Infinity, controller.signal);
      } catch {
      }
      return controller;
    });
    if (options.signal != null) {
      try {
        (0, import_events23.setMaxListeners)?.(Infinity, options.signal);
      } catch {
      }
    }
    let completedDials = 0;
    let done = false;
    try {
      return await Promise.any(this.addrs.map(async (addr, i) => {
        const token = await tokenHolder.shift();
        if (done) {
          this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          throw (0, import_err_code36.default)(new Error("dialAction already succeeded"), codes.ERR_ALREADY_SUCCEEDED);
        }
        const controller = dialAbortControllers[i];
        if (controller == null) {
          throw (0, import_err_code36.default)(new Error("dialAction did not come with an AbortController"), codes.ERR_INVALID_PARAMETERS);
        }
        let conn;
        try {
          const signal = controller.signal;
          conn = await this.dialAction(addr, { ...options, signal: options.signal != null ? (0, import_any_signal.anySignal)([signal, options.signal]) : signal });
          dialAbortControllers[i] = void 0;
        } finally {
          completedDials++;
          if (this.addrs.length - completedDials >= tokens.length) {
            void tokenHolder.push(token).catch((err) => {
              log33.error(err);
            });
          } else {
            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
          }
        }
        if (conn == null) {
          throw (0, import_err_code36.default)(new Error("dialAction led to empty object"), codes.ERR_TRANSPORT_DIAL_FAILED);
        } else {
          done = true;
        }
        return conn;
      }));
    } finally {
      dialAbortControllers.forEach((c) => {
        if (c !== void 0) {
          c.abort();
        }
      });
      tokens.forEach((token) => this.dialer.releaseToken(token));
    }
  }
};

// node_modules/libp2p/dist/src/connection-manager/dialer/index.js
var log34 = logger("libp2p:dialer");
var METRICS_COMPONENT2 = "dialler";
var METRICS_PENDING_DIALS = "pending-dials";
var METRICS_PENDING_DIAL_TARGETS = "pending-dial-targets";
var DefaultDialer = class {
  constructor(components, init = {}) {
    this.started = false;
    this.addressSorter = init.addressSorter ?? publicAddressesFirst;
    this.maxAddrsToDial = init.maxAddrsToDial ?? MAX_ADDRS_TO_DIAL;
    this.timeout = init.dialTimeout ?? DIAL_TIMEOUT;
    this.maxDialsPerPeer = init.maxDialsPerPeer ?? MAX_PER_PEER_DIALS;
    this.tokens = [...new Array(init.maxParallelDials ?? MAX_PARALLEL_DIALS)].map((_, index) => index);
    this.components = components;
    this.pendingDials = trackedMap({
      component: METRICS_COMPONENT2,
      metric: METRICS_PENDING_DIALS,
      metrics: init.metrics
    });
    this.pendingDialTargets = trackedMap({
      component: METRICS_COMPONENT2,
      metric: METRICS_PENDING_DIAL_TARGETS,
      metrics: components.metrics
    });
    for (const [key, value] of Object.entries(init.resolvers ?? {})) {
      resolvers.set(key, value);
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
    for (const dial of this.pendingDials.values()) {
      try {
        dial.controller.abort();
      } catch (err) {
        log34.error(err);
      }
    }
    this.pendingDials.clear();
    for (const pendingTarget of this.pendingDialTargets.values()) {
      pendingTarget.reject(new AbortError("Dialer was destroyed"));
    }
    this.pendingDialTargets.clear();
  }
  async dial(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (this.components.peerId.equals(id)) {
      throw (0, import_err_code37.default)(new Error("Tried to dial self"), codes.ERR_DIALED_SELF);
    }
    log34("check multiaddrs %p", id);
    if (multiaddrs != null && multiaddrs.length > 0) {
      log34("storing multiaddrs %p", id, multiaddrs);
      await this.components.peerStore.addressBook.add(id, multiaddrs);
    }
    if (await this.components.connectionGater.denyDialPeer(id)) {
      throw (0, import_err_code37.default)(new Error("The dial request is blocked by gater.allowDialPeer"), codes.ERR_PEER_DIAL_INTERCEPTED);
    }
    log34("creating dial target for %p", id);
    const dialTarget = await this._createCancellableDialTarget(id, options);
    if (dialTarget.addrs.length === 0) {
      throw (0, import_err_code37.default)(new Error("The dial request has no valid addresses"), codes.ERR_NO_VALID_ADDRESSES);
    }
    const pendingDial = this.pendingDials.get(dialTarget.id) ?? this._createPendingDial(dialTarget, options);
    try {
      const connection = await pendingDial.promise;
      log34("dial succeeded to %s", dialTarget.id);
      return connection;
    } catch (err) {
      log34("dial failed to %s", dialTarget.id, err);
      if (pendingDial.controller.signal.aborted) {
        err.code = codes.ERR_TIMEOUT;
      }
      log34.error(err);
      throw err;
    } finally {
      pendingDial.destroy();
    }
  }
  async _createCancellableDialTarget(peer, options) {
    const id = `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`;
    const cancellablePromise = new Promise((resolve, reject) => {
      this.pendingDialTargets.set(id, { resolve, reject });
    });
    try {
      const dialTarget = await Promise.race([
        this._createDialTarget(peer, options),
        cancellablePromise
      ]);
      return dialTarget;
    } finally {
      this.pendingDialTargets.delete(id);
    }
  }
  async _createDialTarget(peer, options) {
    const _resolve = this._resolve.bind(this);
    const addrs = await pipe(
      await this.components.peerStore.addressBook.get(peer),
      (source) => filter2(source, async (address) => {
        return !await this.components.connectionGater.denyDialMultiaddr(peer, address.multiaddr);
      }),
      (source) => sort(source, this.addressSorter),
      async function* resolve(source) {
        for await (const a of source) {
          yield* await _resolve(a.multiaddr, options);
        }
      },
      (source) => filter2(source, (ma) => Boolean(this.components.transportManager.transportForMultiaddr(ma))),
      (source) => map(source, (ma) => {
        if (peer.toString() === ma.getPeerId()) {
          return ma;
        }
        return ma.encapsulate(`/p2p/${peer.toString()}`);
      }),
      async (source) => await all2(source)
    );
    if (addrs.length > this.maxAddrsToDial) {
      await this.components.peerStore.delete(peer);
      throw (0, import_err_code37.default)(new Error("dial with more addresses than allowed"), codes.ERR_TOO_MANY_ADDRESSES);
    }
    return {
      id: peer.toString(),
      addrs
    };
  }
  _createPendingDial(dialTarget, options = {}) {
    const dialAction = async (addr, options2 = {}) => {
      if (options2.signal?.aborted === true) {
        throw (0, import_err_code37.default)(new Error("already aborted"), codes.ERR_ALREADY_ABORTED);
      }
      return await this.components.transportManager.dial(addr, options2).catch((err) => {
        log34.error("dial to %s failed", addr, err);
        throw err;
      });
    };
    const dialRequest = new DialRequest({
      addrs: dialTarget.addrs,
      dialAction,
      dialer: this
    });
    const timeoutController = new import_timeout_abort_controller8.TimeoutController(this.timeout);
    const signals = [timeoutController.signal];
    options.signal != null && signals.push(options.signal);
    const signal = (0, import_any_signal2.anySignal)(signals);
    try {
      (0, import_events24.setMaxListeners)?.(Infinity, signal);
    } catch {
    }
    const pendingDial = {
      dialRequest,
      controller: timeoutController,
      promise: dialRequest.run({ ...options, signal }),
      destroy: () => {
        timeoutController.clear();
        this.pendingDials.delete(dialTarget.id);
      }
    };
    this.pendingDials.set(dialTarget.id, pendingDial);
    return pendingDial;
  }
  getTokens(num) {
    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
    const tokens = this.tokens.splice(0, total);
    log34("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
    return tokens;
  }
  releaseToken(token) {
    if (this.tokens.includes(token)) {
      return;
    }
    log34("token %d released", token);
    this.tokens.push(token);
  }
  async _resolve(ma, options) {
    const resolvableProto = ma.protoNames().includes("dnsaddr");
    if (!resolvableProto) {
      return [ma];
    }
    const resolvedMultiaddrs = await this._resolveRecord(ma, options);
    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(async (nm) => {
      return await this._resolve(nm, options);
    }));
    const addrs = recursiveMultiaddrs.flat();
    return addrs.reduce((array, newM) => {
      if (array.find((m) => m.equals(newM)) == null) {
        array.push(newM);
      }
      return array;
    }, []);
  }
  async _resolveRecord(ma, options) {
    try {
      ma = multiaddr(ma.toString());
      const multiaddrs = await ma.resolve(options);
      return multiaddrs;
    } catch (err) {
      log34.error(`multiaddr ${ma.toString()} could not be resolved`, err);
      return [];
    }
  }
};

// node_modules/libp2p/dist/src/libp2p.js
var log35 = logger("libp2p");
var Libp2pNode = class extends EventEmitter {
  constructor(init) {
    super();
    this.started = false;
    this.peerId = init.peerId;
    const components = this.components = new DefaultComponents({
      peerId: init.peerId,
      datastore: init.datastore ?? new MemoryDatastore(),
      connectionGater: {
        denyDialPeer: async () => await Promise.resolve(false),
        denyDialMultiaddr: async () => await Promise.resolve(false),
        denyInboundConnection: async () => await Promise.resolve(false),
        denyOutboundConnection: async () => await Promise.resolve(false),
        denyInboundEncryptedConnection: async () => await Promise.resolve(false),
        denyOutboundEncryptedConnection: async () => await Promise.resolve(false),
        denyInboundUpgradedConnection: async () => await Promise.resolve(false),
        denyOutboundUpgradedConnection: async () => await Promise.resolve(false),
        filterMultiaddrForPeer: async () => await Promise.resolve(true),
        ...init.connectionGater
      }
    });
    components.peerStore = new PersistentPeerStore(components, {
      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,
      ...init.peerStore
    });
    this.services = [
      components
    ];
    if (init.metrics.enabled) {
      this.metrics = this.components.metrics = new DefaultMetrics(init.metrics);
    }
    this.peerStore = this.components.peerStore;
    this.peerStore.addEventListener("peer", (evt) => {
      const { detail: peerData } = evt;
      this.dispatchEvent(new CustomEvent("peer:discovery", { detail: peerData }));
    });
    if (init.connectionProtector != null) {
      this.components.connectionProtector = init.connectionProtector(components);
    }
    this.components.upgrader = new DefaultUpgrader(this.components, {
      connectionEncryption: (init.connectionEncryption ?? []).map((fn) => this.configureComponent(fn(this.components))),
      muxers: (init.streamMuxers ?? []).map((fn) => this.configureComponent(fn(this.components))),
      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout
    });
    this.components.dialer = new DefaultDialer(this.components, init.connectionManager);
    this.connectionManager = this.components.connectionManager = new DefaultConnectionManager(this.components, init.connectionManager);
    this.registrar = this.components.registrar = new DefaultRegistrar(this.components);
    this.components.transportManager = new DefaultTransportManager(this.components, init.transportManager);
    this.components.addressManager = new DefaultAddressManager(this.components, init.addresses);
    this.configureComponent(new PeerRecordUpdater(this.components));
    this.configureComponent(new AutoDialler(this.components, {
      enabled: init.connectionManager.autoDial,
      minConnections: init.connectionManager.minConnections,
      autoDialInterval: init.connectionManager.autoDialInterval
    }));
    const keychainOpts = KeyChain.generateOptions();
    this.keychain = this.configureComponent(new KeyChain(this.components, {
      ...keychainOpts,
      ...init.keychain
    }));
    this.services.push(new NatManager(this.components, init.nat));
    init.transports.forEach((fn) => {
      this.components.transportManager.add(this.configureComponent(fn(this.components)));
    });
    this.identifyService = new IdentifyService(this.components, {
      ...init.identify
    });
    this.configureComponent(this.identifyService);
    if (init.dht != null) {
      this.dht = this.components.dht = init.dht(this.components);
    } else {
      this.dht = new DummyDHT();
    }
    if (init.pubsub != null) {
      this.pubsub = this.components.pubsub = init.pubsub(this.components);
    } else {
      this.pubsub = new DummyPubSub();
    }
    const peerRouters = (init.peerRouters ?? []).map((fn) => this.configureComponent(fn(this.components)));
    if (init.dht != null) {
      peerRouters.push(this.configureComponent(new DHTPeerRouting(this.dht)));
      this.dht.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
    this.peerRouting = this.components.peerRouting = this.configureComponent(new DefaultPeerRouting(this.components, {
      ...init.peerRouting,
      routers: peerRouters
    }));
    const contentRouters = (init.contentRouters ?? []).map((fn) => this.configureComponent(fn(this.components)));
    if (init.dht != null) {
      contentRouters.push(this.configureComponent(new DHTContentRouting(this.dht)));
    }
    this.contentRouting = this.components.contentRouting = this.configureComponent(new CompoundContentRouting(this.components, {
      routers: contentRouters
    }));
    if (init.relay.enabled) {
      this.components.transportManager.add(this.configureComponent(new Circuit2(this.components, init.relay)));
      this.configureComponent(new Relay(this.components, {
        addressSorter: init.connectionManager.addressSorter,
        ...init.relay
      }));
    }
    this.fetchService = this.configureComponent(new FetchService(this.components, {
      ...init.fetch
    }));
    this.pingService = this.configureComponent(new PingService(this.components, {
      ...init.ping
    }));
    for (const fn of init.peerDiscovery ?? []) {
      const service = this.configureComponent(fn(this.components));
      service.addEventListener("peer", (evt) => {
        this.onDiscoveryPeer(evt);
      });
    }
  }
  configureComponent(component) {
    if (isStartable(component)) {
      this.services.push(component);
    }
    return component;
  }
  async start() {
    if (this.started) {
      return;
    }
    this.started = true;
    log35("libp2p is starting");
    try {
      await Promise.all(this.services.map(async (service) => {
        if (service.beforeStart != null) {
          await service.beforeStart();
        }
      }));
      await Promise.all(this.services.map((service) => service.start()));
      await Promise.all(this.services.map(async (service) => {
        if (service.afterStart != null) {
          await service.afterStart();
        }
      }));
      log35("libp2p has started");
    } catch (err) {
      log35.error("An error occurred starting libp2p", err);
      await this.stop();
      throw err;
    }
  }
  async stop() {
    if (!this.started) {
      return;
    }
    log35("libp2p is stopping");
    this.started = false;
    await Promise.all(this.services.map(async (service) => {
      if (service.beforeStop != null) {
        await service.beforeStop();
      }
    }));
    await Promise.all(this.services.map((service) => service.stop()));
    await Promise.all(this.services.map(async (service) => {
      if (service.afterStop != null) {
        await service.afterStop();
      }
    }));
    log35("libp2p has stopped");
  }
  isStarted() {
    return this.started;
  }
  getConnections(peerId) {
    return this.components.connectionManager.getConnections(peerId);
  }
  getPeers() {
    const peerSet = new PeerSet();
    for (const conn of this.components.connectionManager.getConnections()) {
      peerSet.add(conn.remotePeer);
    }
    return Array.from(peerSet);
  }
  async dial(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    await this.components.peerStore.addressBook.add(id, multiaddrs);
    return await this.components.connectionManager.openConnection(id, options);
  }
  async dialProtocol(peer, protocols, options = {}) {
    if (protocols == null) {
      throw (0, import_err_code38.default)(new Error("no protocols were provided to open a stream"), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    if (protocols.length === 0) {
      throw (0, import_err_code38.default)(new Error("no protocols were provided to open a stream"), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
    }
    const connection = await this.dial(peer, options);
    return await connection.newStream(protocols, options);
  }
  getMultiaddrs() {
    return this.components.addressManager.getAddresses();
  }
  async hangUp(peer) {
    const { id } = getPeer(peer);
    await this.components.connectionManager.closeConnections(id);
  }
  async getPublicKey(peer, options = {}) {
    log35("getPublicKey %p", peer);
    if (peer.publicKey != null) {
      return peer.publicKey;
    }
    const peerInfo = await this.peerStore.get(peer);
    if (peerInfo.pubKey != null) {
      return peerInfo.pubKey;
    }
    if (this.dht == null) {
      throw (0, import_err_code38.default)(new Error("Public key was not in the peer store and the DHT is not enabled"), codes.ERR_NO_ROUTERS_AVAILABLE);
    }
    const peerKey = concat([
      fromString2("/pk/"),
      peer.multihash.digest
    ]);
    for await (const event of this.dht.get(peerKey, options)) {
      if (event.name === "VALUE") {
        const key = unmarshalPublicKey(event.value);
        await this.peerStore.keyBook.set(peer, event.value);
        return key.bytes;
      }
    }
    throw (0, import_err_code38.default)(new Error(`Node not responding with its public key: ${peer.toString()}`), codes.ERR_INVALID_RECORD);
  }
  async fetch(peer, key, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (multiaddrs != null) {
      await this.components.peerStore.addressBook.add(id, multiaddrs);
    }
    return await this.fetchService.fetch(id, key, options);
  }
  async ping(peer, options = {}) {
    const { id, multiaddrs } = getPeer(peer);
    if (multiaddrs.length > 0) {
      await this.components.peerStore.addressBook.add(id, multiaddrs);
    }
    return await this.pingService.ping(id, options);
  }
  async handle(protocols, handler, options) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.handle(protocol, handler, options);
    }));
  }
  async unhandle(protocols) {
    if (!Array.isArray(protocols)) {
      protocols = [protocols];
    }
    await Promise.all(protocols.map(async (protocol) => {
      await this.components.registrar.unhandle(protocol);
    }));
  }
  onDiscoveryPeer(evt) {
    const { detail: peer } = evt;
    if (peer.id.toString() === this.peerId.toString()) {
      log35.error(new Error(codes.ERR_DISCOVERED_SELF));
      return;
    }
    if (peer.multiaddrs.length > 0) {
      void this.components.peerStore.addressBook.add(peer.id, peer.multiaddrs).catch((err) => log35.error(err));
    }
    if (peer.protocols.length > 0) {
      void this.components.peerStore.protoBook.set(peer.id, peer.protocols).catch((err) => log35.error(err));
    }
    this.dispatchEvent(new CustomEvent("peer:discovery", { detail: peer }));
  }
};
async function createLibp2pNode(options) {
  if (options.peerId == null) {
    options.peerId = await createEd25519PeerId();
  }
  return new Libp2pNode(validateConfig(options));
}

// node_modules/libp2p/dist/src/index.js
async function createLibp2p(options) {
  return await createLibp2pNode(options);
}
export {
  createLibp2p
};
//# sourceMappingURL=libp2p.js.map
